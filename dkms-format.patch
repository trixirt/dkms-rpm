diff --git a/dkms b/dkms
index 09f74bc..0a81c82 100644
--- a/dkms
+++ b/dkms
@@ -24,16 +24,16 @@
 # All of the variables we will accept from dkms.conf.
 # Does not include directives
 readonly dkms_conf_variables="CLEAN REMAKE_INITRD remake_initrd PACKAGE_NAME
-       PACKAGE_VERSION POST_ADD POST_BUILD POST_INSTALL POST_REMOVE PRE_BUILD
-       PRE_INSTALL BUILD_DEPENDS BUILD_EXCLUSIVE_KERNEL BUILD_EXCLUSIVE_ARCH
-       build_exclude OBSOLETE_BY MAKE MAKE_MATCH MODULES_CONF
-       modules_conf_array PATCH PATCH_MATCH patch_array BUILT_MODULE_NAME
-       built_module_name BUILT_MODULE_LOCATION built_module_location
-       DEST_MODULE_NAME dest_module_name MODULES_CONF_OBSOLETES
-       DEST_MODULE_LOCATION dest_module_location
-       modules_conf_obsoletes MODULES_CONF_ALIAS_TYPE
-       modules_conf_alias_type STRIP strip MODULES_CONF_OBSOLETE_ONLY
-       modules_conf_obsolete_only AUTOINSTALL"
+   PACKAGE_VERSION POST_ADD POST_BUILD POST_INSTALL POST_REMOVE PRE_BUILD
+   PRE_INSTALL BUILD_DEPENDS BUILD_EXCLUSIVE_KERNEL BUILD_EXCLUSIVE_ARCH
+   build_exclude OBSOLETE_BY MAKE MAKE_MATCH MODULES_CONF
+   modules_conf_array PATCH PATCH_MATCH patch_array BUILT_MODULE_NAME
+   built_module_name BUILT_MODULE_LOCATION built_module_location
+   DEST_MODULE_NAME dest_module_name MODULES_CONF_OBSOLETES
+   DEST_MODULE_LOCATION dest_module_location
+   modules_conf_obsoletes MODULES_CONF_ALIAS_TYPE
+   modules_conf_alias_type STRIP strip MODULES_CONF_OBSOLETE_ONLY
+   modules_conf_obsolete_only AUTOINSTALL"
 
 # Some important regular expressions.  Requires bash 3 or above.
 # Any poor souls still running bash 2 or older really need an upgrade.
@@ -41,7 +41,7 @@ readonly y_re='^(Y|y)'
 readonly mv_re='^([^/]*)/(.*)$'
 readonly rh_kernels='(debug|summit|smp|enterprise|bigmem|hugemem|BOOT|vmnix)'
 
-#Areas that will vary between Linux and other OS's
+# Areas that will vary between Linux and other OS's
 _get_kernel_dir() {
     KVER=$1
     case ${current_os} in
@@ -70,18 +70,18 @@ invoke_command()
     local exitval=0
     [[ $verbose ]] && echo -e "$1" || echo -en "$2..."
     if [[ $3 = background && ! $verbose ]]; then
-	local pid progresspid
-	(eval "$1" >/dev/null 2>&1) & pid=$!
-	while [ -d /proc/$pid ]; do
-		sleep 3
-		echo -en "."
-	done & progresspid=$!
-	wait $pid 2>/dev/null
-	exitval=$?
-	kill $progresspid 2>/dev/null
-	wait $progresspid 2>/dev/null
+        local pid progresspid
+        (eval "$1" >/dev/null 2>&1) & pid=$!
+        while [ -d /proc/$pid ]; do
+            sleep 3
+            echo -en "."
+        done & progresspid=$!
+        wait $pid 2>/dev/null
+        exitval=$?
+        kill $progresspid 2>/dev/null
+        wait $progresspid 2>/dev/null
     else
-	eval "$1"; exitval=$?
+        eval "$1"; exitval=$?
     fi
     (($exitval > 0)) && echo -en "(bad exit status: $exitval)"
     echo -en "\n"
@@ -141,11 +141,11 @@ VER()
     # The result should compare correctly as a string.
 
     echo $1 | sed -e 's:\([^0-9]\)\([0-9]\):\1 \2:g' \
-		  -e 's:\([0-9]\)\([^0-9]\):\1 \2:g' \
-		  -e 's:\(.*\): \1 :' \
-		  -e 's: \([0-9]\) : 00\1 :g' \
-		  -e 's: \([0-9][0-9]\) : 0\1 :g' \
-		  -e 's: ::g'
+        -e 's:\([0-9]\)\([^0-9]\):\1 \2:g' \
+        -e 's:\(.*\): \1 :' \
+        -e 's: \([0-9]\) : 00\1 :g' \
+        -e 's: \([0-9][0-9]\) : 0\1 :g' \
+        -e 's: ::g'
 }
 
 # Figure out the correct module suffix for the kernel we are currently
@@ -166,14 +166,14 @@ set_kernel_source_dir()
 
 # A little test function for DKMS commands that only work on one kernel.
 have_one_kernel() {
-       if (( ${#kernelver[@]} != 1 )); then
-	  die 4 $"The action $1 does not support multiple kernel version" \
-	  $"parameters on the command line."
-       fi
-       if [[ $all ]]; then
-           die 5 $"The action $1 does not support the --all" \
-	   $"parameter."
-       fi
+    if (( ${#kernelver[@]} != 1 )); then
+        die 4 $"The action $1 does not support multiple kernel version" \
+        $"parameters on the command line."
+    fi
+    if [[ $all ]]; then
+        die 5 $"The action $1 does not support the --all" \
+        $"parameter."
+    fi
 }
 
 # Set up the kernelver and arch arrays.  You must have a 1:1 correspondence --
@@ -185,53 +185,50 @@ setup_kernels_arches()
 {
     # If all is set, use dkms status to fill the arrays
     if [[ $all && $1 != status ]]; then
-	local i=0
-	while read line; do
-	    line=${line#*/}; line=${line#*/};
-	    # (I would leave out the delimiters in the status output
-	    #  in the first place.)
-	    kernelver[$i]=${line%/*}
-	    arch[$i]=${line#*/}
-	    i=$(($i + 1))
-	done < <(module_status_built "$module" "$module_version")
+        local i=0
+        while read line; do
+            line=${line#*/}; line=${line#*/};
+            # (I would leave out the delimiters in the status output
+            #  in the first place.)
+            kernelver[$i]=${line%/*}
+            arch[$i]=${line#*/}
+            i=$(($i + 1))
+        done < <(module_status_built "$module" "$module_version")
     fi
 
     # Set default kernel version and arch, if none set (but only --all isn't set)
     if [[ $1 != status ]]; then
-	if [[ ! $kernelver && ! $all ]]; then
-	    kernelver[0]=$(uname -r)
-	    kernels_arches_default="yes"
-	fi
-	if [[ ! $arch ]]; then
-	    kernelver_rpm=$(rpm -qf "/lib/modules/$kernelver" 2>/dev/null | \
-		grep -v "not owned by any package" | grep kernel | head -n 1)
-	    if ! arch[0]=$(rpm -q --queryformat "%{ARCH}" "$kernelver_rpm" 2>/dev/null); then
-		arch[0]=$(uname -m)
-		if [[ $arch = x86_64 ]] && \
-		    grep -q Intel /proc/cpuinfo && \
-		    ls $install_tree/$kernelver/build/configs \
-		    2>/dev/null | grep -q "ia32e"; then
-		    arch[0]="ia32e"
-		fi
-	    fi
-	fi
+        if [[ ! $kernelver && ! $all ]]; then
+            kernelver[0]=$(uname -r)
+            kernels_arches_default="yes"
+        fi
+        if [[ ! $arch ]]; then
+            kernelver_rpm=$(rpm -qf "/lib/modules/$kernelver" 2>/dev/null | \
+            grep -v "not owned by any package" | grep kernel | head -n 1)
+            if ! arch[0]=$(rpm -q --queryformat "%{ARCH}" "$kernelver_rpm" 2>/dev/null); then
+                arch[0]=$(uname -m)
+                if [[ $arch = x86_64 ]] && grep -q Intel /proc/cpuinfo && ls $install_tree/$kernelver/build/configs 2>/dev/null | grep -q "ia32e"; then
+                    arch[0]="ia32e"
+                fi
+            fi
+        fi
     fi
 
     # If only one arch is specified, make it so for all the kernels
     if ((${#arch[@]} == 1 && ${#kernelver[@]} > 1)); then
-	while ((${#arch[@]} < ${#kernelver[@]})); do
-	    arch[${#arch[@]}]=$arch
-	done
+        while ((${#arch[@]} < ${#kernelver[@]})); do
+            arch[${#arch[@]}]=$arch
+        done
     fi
 
     # Set global multi_arch
     multi_arch=""
     local i=0
     for ((i=0; $i < ${#arch[@]}; i++)); do
-	[[ $arch != ${arch[$i]} ]] && {
-	    multi_arch="true"
-	    break
-	}
+        [[ $arch != ${arch[$i]} ]] && {
+            multi_arch="true"
+            break
+        }
     done
 }
 
@@ -245,9 +242,9 @@ do_depmod()
         return
     fi
     if [[ -f /boot/System.map-$1 ]]; then
-	depmod -a "$1" -F "/boot/System.map-$1"
+        depmod -a "$1" -F "/boot/System.map-$1"
     else
-	depmod -a "$1"
+        depmod -a "$1"
     fi
 }
 
@@ -261,24 +258,24 @@ make_initrd()
     [[ $no_initrd ]] && return
     local mkinitrd kernel_file initrd_dir="/boot"
     for mkinitrd in dracut update-initramfs mkinitrd ''; do
-	[[ $mkinitrd ]] && which "$mkinitrd" >/dev/null 2>&1 && break
+        [[ $mkinitrd ]] && which "$mkinitrd" >/dev/null 2>&1 && break
     done
 
-    # no mkinitrd? Just return.
+    # No mkinitrd? Just return.
     [[ $mkinitrd ]] || return 0
 
-    # back up our current initrd
+    # Back up our current initrd
     echo $""
     [[ $2 = ia64 && -d /boot/efi/efi/redhat ]] && initrd_dir="/boot/efi/efi/redhat"
-    # find out what the proper filename will be
+    # Find out what the proper filename will be
     for initrd in "initrd-$1.img" "initramfs-$1.img" "initrd.img-$1" "initrd-$1" ''; do
-	[[ $initrd && -f $initrd_dir/$initrd ]] && break
+        [[ $initrd && -f $initrd_dir/$initrd ]] && break
     done
     if ! [[ $initrd ]]; then
-	# Return if we cannot find an initrd.
-	warn $"Unable to find an initial ram disk that I know how to handle." \
-	    $"Will not try to make an initrd."
-	return 0
+        # Return if we cannot find an initrd.
+        warn $"Unable to find an initial ram disk that I know how to handle." \
+            $"Will not try to make an initrd."
+        return 0
     fi
     echo $"Backing up $initrd to $initrd_dir/$initrd.old-dkms"
     cp -f "$initrd_dir/$initrd" "$initrd_dir/$initrd.old-dkms"
@@ -286,27 +283,27 @@ make_initrd()
     echo $"(If next boot fails, revert to $initrd.old-dkms image)"
 
     if [[ $mkinitrd = dracut ]]; then
-	invoke_command "$mkinitrd -f $initrd_dir/$initrd $1" "$mkinitrd" background
+        invoke_command "$mkinitrd -f $initrd_dir/$initrd $1" "$mkinitrd" background
     elif [[ $mkinitrd = update-initramfs ]]; then
-	invoke_command "$mkinitrd -u" "$mkinitrd" background
+        invoke_command "$mkinitrd -u" "$mkinitrd" background
     elif $mkinitrd --version >/dev/null 2>&1; then
-	invoke_command "$mkinitrd -f $initrd_dir/$initrd $1" "$mkinitrd" background
+        invoke_command "$mkinitrd -f $initrd_dir/$initrd $1" "$mkinitrd" background
     elif [[ -e /etc/SuSE-release || -d /etc/SuSEconfig ]]; then
-	for kernel_file in vmlinuz vmlinux ''; do
-	    [[ $kernel_file && -f $initrd_dir/$kernel_file ]] && break
-	done
-	if [[ ! $kernel_file ]]; then
-	    error $"Unable to find valid kernel file under " \
-		$"$initrd_dir for kernel version $1" 
-	    return 1;
-	fi
-	invoke_command "$mkinitrd -k $kernel_file-$1 -i $initrd" "$mkinitrd" background
+        for kernel_file in vmlinuz vmlinux ''; do
+            [[ $kernel_file && -f $initrd_dir/$kernel_file ]] && break
+        done
+        if [[ ! $kernel_file ]]; then
+            error $"Unable to find valid kernel file under " \
+            $"$initrd_dir for kernel version $1" 
+            return 1;
+        fi
+        invoke_command "$mkinitrd -k $kernel_file-$1 -i $initrd" "$mkinitrd" background
     elif [[ -e /etc/debian_version ]]; then
-	invoke_command "$mkinitrd -o $initrd_dir/$initrd $1" "$mkinitrd" background
+        invoke_command "$mkinitrd -o $initrd_dir/$initrd $1" "$mkinitrd" background
     else
-	echo $""
-	echo $"Calling $mkinitrd (bad exit status 9 may occur)"
-	invoke_command "$mkinitrd" "$mkinitrd" background
+        echo $""
+        echo $"Calling $mkinitrd (bad exit status 9 may occur)"
+        invoke_command "$mkinitrd" "$mkinitrd" background
     fi
     return
 }
@@ -318,26 +315,41 @@ distro_version_rpm()
     local r wp ver dist
 
     for r in redhat-release sles-release suse-release ovs-release; do
-	wp=$(rpm -q --whatprovides "$r") || continue
-	ver=$(rpm -q --qf "%{version}\n" ${wp})
-	case $r in
-	    sles*) echo sles${ver};;
-	    suse*) echo suse${ver};;
-	    ovs*)  echo ovm${ver};;
-	    redhat*)
-		case $wp in
-		    redhat*|sl*)
-			ver=$(echo $ver | \
-			sed -e 's/^\([[:digit:]]*\).*/\1/g')
-			echo el${ver};;
-		    centos*|enterprise*) echo el${ver};;
-		    fedora*) echo fc${ver};;
-		    *) echo unknown ;;
-		esac
-	       ;;
-	    *) echo unknown;;
-	esac
-	return
+        wp=$(rpm -q --whatprovides "$r") || continue
+        ver=$(rpm -q --qf "%{version}\n" ${wp})
+        case $r in
+            sles*)
+                echo sles${ver}
+                ;;
+            suse*)
+                echo suse${ver}
+                ;;
+            ovs*)
+                echo ovm${ver}
+                ;;
+            redhat*)
+                case $wp in
+                    redhat*|sl*)
+                        ver=$(echo $ver | \
+                        sed -e 's/^\([[:digit:]]*\).*/\1/g')
+                        echo el${ver}
+                        ;;
+                    centos*|enterprise*)
+                        echo el${ver}
+                        ;;
+                    fedora*)
+                        echo fc${ver}
+                        ;;
+                    *)
+                        echo unknown
+                        ;;
+                esac
+                ;;
+            *)
+                echo unknown
+                ;;
+        esac
+        return
     done
     echo unknown
 }
@@ -349,36 +361,38 @@ distro_version()
     # What distribution are we running?
     local LSB_DESCRIPTION DISTRIB_ID DISTRIB_RELEASE ver
 
-    # try the LSB-provided strings first
+    # Try the LSB-provided strings first
     if [ -r /etc/lsb-release ]; then
-	. /etc/lsb-release
+        . /etc/lsb-release
     elif type lsb_release >/dev/null 2>&1; then
-	DISTRIB_ID=$(lsb_release -i -s)
-	DISTRIB_RELEASE=$(lsb_release -r -s)
+        DISTRIB_ID=$(lsb_release -i -s)
+        DISTRIB_RELEASE=$(lsb_release -r -s)
     fi
 
     case ${DISTRIB_ID} in
-	Fedora)     echo fc${DISTRIB_RELEASE} ;;
-	RedHatEnterprise*|CentOS|ScientificSL)  # OEL also reports as such
-	# format is 4.7, 5.3
-	    ver=$(echo "${DISTRIB_RELEASE}" | \
-		sed -e 's/^\([[:digit:]]*\).*/\1/g')
-	    echo el${ver}
-	    ;;
-	SUSE*)
-	    if [[ $(lsb_release -d -s) =~ Enterprise ]]; then
-		echo sles${DISTRIB_RELEASE}
-	    else
-		echo suse${DISTRIB_RELEASE}
-	    fi
-	    ;;
-	*)
-	    if [[ ${DISTRIB_ID} && ${DISTRIB_RELEASE} ]]; then
-		echo "${DISTRIB_ID}${DISTRIB_RELEASE}"
-	    else
-		distro_version_rpm
-	    fi
-	    ;;
+        Fedora)
+            echo fc${DISTRIB_RELEASE}
+            ;;
+        RedHatEnterprise*|CentOS|ScientificSL)
+            # OEL also reports as such; format is 4.7, 5.3
+            ver=$(echo "${DISTRIB_RELEASE}" | \
+            sed -e 's/^\([[:digit:]]*\).*/\1/g')
+            echo el${ver}
+            ;;
+        SUSE*)
+            if [[ $(lsb_release -d -s) =~ Enterprise ]]; then
+                echo sles${DISTRIB_RELEASE}
+            else
+                echo suse${DISTRIB_RELEASE}
+            fi
+            ;;
+        *)
+            if [[ ${DISTRIB_ID} && ${DISTRIB_RELEASE} ]]; then
+                echo "${DISTRIB_ID}${DISTRIB_RELEASE}"
+            else
+                distro_version_rpm
+            fi
+            ;;
     esac
 }
 
@@ -388,24 +402,44 @@ override_dest_module_location()
     [[ ${addon_modules_dir} ]] && echo "/${addon_modules_dir}" && return
 
     if [ "$current_os" = "GNU/kFreeBSD" ] ; then
-	# Does not support subdirs, regardless of distribution
-	echo "" && return
+        # Does not support subdirs, regardless of distribution
+        echo "" && return
     fi
 
     case "$running_distribution" in
-	fc[12345]) ;;
-	el[1234]) ;;
-	sles[123456789]) ;;
-	suse[123456789]) ;;
-	suse10\.[01]) ;;
-	fc*) echo "/extra" && return ;;
-	el*) echo "/extra" && return ;;
-	ovm*) echo "/extra" && return ;;
-	sles*) echo "/updates" && return ;;
-	suse*) echo "/updates" && return ;;
-	Ubuntu*) echo "/updates/dkms" && return ;;
-	Debian*) echo "/updates/dkms" && return ;;
-	*) ;;
+    fc[12345])
+        ;;
+    el[1234])
+        ;;
+    sles[123456789])
+        ;;
+    suse[123456789])
+        ;;
+    suse10\.[01])
+        ;;
+    fc*)
+        echo "/extra" && return
+        ;;
+    el*)
+        echo "/extra" && return
+        ;;
+    ovm*)
+        echo "/extra" && return
+        ;;
+    sles*)
+        echo "/updates" && return
+        ;;
+    suse*)
+        echo "/updates" && return
+        ;;
+    Ubuntu*)
+        echo "/updates/dkms" && return
+        ;;
+    Debian*)
+        echo "/updates/dkms" && return
+        ;;
+    *)
+        ;;
     esac
     echo "$orig_location"
 }
@@ -423,21 +457,21 @@ safe_source() {
     declare -a -r export_envs=("$@")
     local tmpfile=$(mktemp_or_die)
     ( exec >"$tmpfile"
-	. "$to_source_file" >/dev/null
-	# This is really ugly, but a neat hack
-	# Remember, in bash 2.0 and greater all variables are really arrays.
-	for _export_env in "${export_envs[@]}"; do
-	    for _i in $(eval echo \${!$_export_env[@]}); do
-		eval echo '$_export_env[$_i]=\"${'$_export_env'[$_i]}\"'
-	    done
-	done
-
-	# handle DKMS_DIRECTIVE stuff specially.
-	for directive in $(set | grep ^DKMS_DIRECTIVE | cut -d = -f 2-3); do
-	    directive_name=${directive%%=*}
-	    directive_value=${directive#*=}
-	    echo "$directive_name=\"$directive_value\""
-	done
+    . "$to_source_file" >/dev/null
+    # This is really ugly, but a neat hack
+    # Remember, in bash 2.0 and greater all variables are really arrays.
+    for _export_env in "${export_envs[@]}"; do
+        for _i in $(eval echo \${!$_export_env[@]}); do
+            eval echo '$_export_env[$_i]=\"${'$_export_env'[$_i]}\"'
+        done
+    done
+
+    # handle DKMS_DIRECTIVE stuff specially.
+    for directive in $(set | grep ^DKMS_DIRECTIVE | cut -d = -f 2-3); do
+        directive_name=${directive%%=*}
+        directive_value=${directive#*=}
+        echo "$directive_name=\"$directive_value\""
+    done
     )
     . "$tmpfile"
     rm "$tmpfile"
@@ -466,15 +500,15 @@ read_conf()
     [[ $3 ]] && read_conf_file="$3"
 
     [[ -r $read_conf_file ]] || die 4 $"Could not locate dkms.conf file." \
-	$"File: $conf does not exist."
+    $"File: $conf does not exist."
 
     [[ $last_mvka = $module/$module_version/$1/$2 && \
-	$last_mvka_conf = $(readlink -f $read_conf_file) ]] && return
+    $last_mvka_conf = $(readlink -f $read_conf_file) ]] && return
 
 
     # Clear variables and arrays
     for var in $dkms_conf_variables; do
-	unset $var
+        unset $var
     done
 
     # Source in the dkms.conf.
@@ -488,10 +522,10 @@ read_conf()
 
     # Source in the directive_array
     for directive in "${directive_array[@]}"; do
-	directive_name=${directive%%=*}
-	directive_value=${directive#*=}
-	export $directive_name="$directive_value"
-	echo $"DIRECTIVE: $directive_name=\"$directive_value\""
+        directive_name=${directive%%=*}
+        directive_value=${directive#*=}
+        export $directive_name="$directive_value"
+        echo $"DIRECTIVE: $directive_name=\"$directive_value\""
     done
 
     # Set variables
@@ -509,149 +543,152 @@ read_conf()
     # Set module naming/location arrays
     local index array_size=0 s
     for s in ${#BUILT_MODULE_NAME[@]} \
-	${#BUILT_MODULE_LOCATION[@]} \
-	${#DEST_MODULE_NAME[@]} \
-	${#DEST_MODULE_LOCATION[@]}; do
-	((s > array_size)) && array_size=$s
+        ${#BUILT_MODULE_LOCATION[@]} \
+        ${#DEST_MODULE_NAME[@]} \
+        ${#DEST_MODULE_LOCATION[@]}; do
+        ((s > array_size)) && array_size=$s
     done
     for ((index=0; index < array_size; index++)); do
-	# Set values
-	built_module_name[$index]=${BUILT_MODULE_NAME[$index]}
-	built_module_location[$index]=${BUILT_MODULE_LOCATION[$index]}
-	dest_module_name[$index]=${DEST_MODULE_NAME[$index]}
-	dest_module_location[$index]=${DEST_MODULE_LOCATION[$index]}
-	modules_conf_obsoletes[$index]=${MODULES_CONF_OBSOLETES[$index]}
-	modules_conf_alias_type[$index]=${MODULES_CONF_ALIAS_TYPE[$index]}
-	case ${MODULES_CONF_OBSOLETE_ONLY[$index]} in
-	    [yY]*) modules_conf_obsolete_only[$index]="yes";;
-	esac
-	case ${STRIP[$index]} in
-	    [nN]*) strip[$index]="no";;
-	    [yY]*) strip[$index]="yes";;
-	    '')    strip[$index]=${strip[0]:-yes};;
-	esac
-
-	# If unset, set by defaults
-	[[ ! ${built_module_name[$index]} ]] && \
-	    ((${#DEST_MODULE_LOCATION[@]} == 1)) && \
-	    built_module_name[$index]=$module
-	[[ ! ${dest_module_name[$index]} ]] && \
-	    dest_module_name[$index]=${built_module_name[$index]}
-	[[ ${built_module_location[$index]} && \
-	    ${built_module_location[$index]:(-1)} != / ]] && \
-	    built_module_location[$index]="${built_module_location[$index]}/"
-
-	# FAIL if no built_module_name
-	if [[ ! ${built_module_name[$index]} ]]; then
-	    echo $"dkms.conf: Error! No 'BUILT_MODULE_NAME' directive specified for record #$index." >&2
-	    return_value=1
-	fi
-
-	# FAIL if built_module_name ends in .o or .ko
-	case ${built_module_name[$index]} in
-	*.o|*.ko)
-	    echo $"dkms.conf: Error! 'BUILT_MODULE_NAME' directive ends in '.o' or '.ko' in record #$index." >&2
-	    return_value=1
-	    ;;
-	esac
-
-	# FAIL if dest_module_name ends in .o or .ko
-	case ${dest_module_name[$index]} in
-	*.o|*.ko)
-	    echo $"dkms.conf: Error! 'DEST_MODULE_NAME' directive ends in '.o' or '.ko' in record #$index." >&2
-	    return_value=1
-	    ;;
-	esac
-
-	# Override location for specific kernels
-	dest_module_location[$index]="$(override_dest_module_location ${dest_module_location[$index]})"
-
-	# Fail if no DEST_MODULE_LOCATION
-	if [[ ! ${DEST_MODULE_LOCATION[$index]} ]]; then
-	    echo $"dkms.conf: Error! No 'DEST_MODULE_LOCATION' directive specified for record #$index.">&2
-	    return_value=1
-	fi
-	    # Fail if bad DEST_MODULE_LOCATION
-	case ${DEST_MODULE_LOCATION[$index]} in
-	    /kernel*) ;;
-	    /updates*) ;;
-	    /extra*) ;;
-	    *)
-		echo $"dkms.conf: Error! Directive 'DEST_MODULE_LOCATION' does not begin with">&2
-		echo $"'/kernel', '/updates', or '/extra' in record #$index.">&2
-		return_value=1
-		;;
-	esac
+        # Set values
+        built_module_name[$index]=${BUILT_MODULE_NAME[$index]}
+        built_module_location[$index]=${BUILT_MODULE_LOCATION[$index]}
+        dest_module_name[$index]=${DEST_MODULE_NAME[$index]}
+        dest_module_location[$index]=${DEST_MODULE_LOCATION[$index]}
+        modules_conf_obsoletes[$index]=${MODULES_CONF_OBSOLETES[$index]}
+        modules_conf_alias_type[$index]=${MODULES_CONF_ALIAS_TYPE[$index]}
+        case ${MODULES_CONF_OBSOLETE_ONLY[$index]} in
+            [yY]*)
+                modules_conf_obsolete_only[$index]="yes"
+                ;;
+        esac
+        case ${STRIP[$index]} in
+            [nN]*)
+                strip[$index]="no"
+                ;;
+            [yY]*)
+                strip[$index]="yes"
+                ;;
+            '')
+                strip[$index]=${strip[0]:-yes}
+                ;;
+        esac
+
+        # If unset, set by defaults
+        [[ ! ${built_module_name[$index]} ]] && \
+            ((${#DEST_MODULE_LOCATION[@]} == 1)) && \
+            built_module_name[$index]=$module
+        [[ ! ${dest_module_name[$index]} ]] && \
+            dest_module_name[$index]=${built_module_name[$index]}
+        [[ ${built_module_location[$index]} && \
+            ${built_module_location[$index]:(-1)} != / ]] && \
+            built_module_location[$index]="${built_module_location[$index]}/"
+
+        # FAIL if no built_module_name
+        if [[ ! ${built_module_name[$index]} ]]; then
+            echo $"dkms.conf: Error! No 'BUILT_MODULE_NAME' directive specified for record #$index." >&2
+            return_value=1
+        fi
+
+        # FAIL if built_module_name ends in .o or .ko
+        case ${built_module_name[$index]} in
+            *.o|*.ko)
+                echo $"dkms.conf: Error! 'BUILT_MODULE_NAME' directive ends in '.o' or '.ko' in record #$index." >&2
+                return_value=1
+                ;;
+        esac
+
+        # FAIL if dest_module_name ends in .o or .ko
+        case ${dest_module_name[$index]} in
+            *.o|*.ko)
+                echo $"dkms.conf: Error! 'DEST_MODULE_NAME' directive ends in '.o' or '.ko' in record #$index." >&2
+                return_value=1
+                ;;
+        esac
+
+        # Override location for specific kernels
+        dest_module_location[$index]="$(override_dest_module_location ${dest_module_location[$index]})"
+
+        # Fail if no DEST_MODULE_LOCATION
+        if [[ ! ${DEST_MODULE_LOCATION[$index]} ]]; then
+            echo $"dkms.conf: Error! No 'DEST_MODULE_LOCATION' directive specified for record #$index.">&2
+            return_value=1
+        fi
+            # Fail if bad DEST_MODULE_LOCATION
+        case ${DEST_MODULE_LOCATION[$index]} in
+            /kernel*)
+                ;;
+            /updates*)
+                ;;
+            /extra*)
+                ;;
+            *)
+            echo $"dkms.conf: Error! Directive 'DEST_MODULE_LOCATION' does not begin with">&2
+            echo $"'/kernel', '/updates', or '/extra' in record #$index.">&2
+            return_value=1
+            ;;
+        esac
     done
 
     # Get the correct make command
     [[ ${MAKE_MATCH[0]} ]] || make_command="${MAKE[0]}"
     for ((index=0; index < ${#MAKE[@]}; index++)); do
-	[[ ${MAKE[$index]} && ${MAKE_MATCH[$index]} && \
-	    $1 =~ ${MAKE_MATCH[$index]} ]] && \
-	    make_command="${MAKE[$index]}"
+    [[ ${MAKE[$index]} && ${MAKE_MATCH[$index]} && \
+        $1 =~ ${MAKE_MATCH[$index]} ]] && \
+        make_command="${MAKE[$index]}"
     done
 
     # Use the generic make and make clean commands if not specified
     if [[ $(VER $1) < $(VER 2.6.6) ]]; then
-	[[ ! $make_command ]] && \
-	    make_command="make -C $kernel_source_dir SUBDIRS=$dkms_tree/$module/$module_version/build modules"
-	[[ ! $clean ]] && \
-	    clean="make -C $kernel_source_dir SUBDIRS=$dkms_tree/$module/$module_version/build clean"
+        [[ ! $make_command ]] && make_command="make -C $kernel_source_dir SUBDIRS=$dkms_tree/$module/$module_version/build modules"
+        [[ ! $clean ]] && clean="make -C $kernel_source_dir SUBDIRS=$dkms_tree/$module/$module_version/build clean"
     else
-	[[ ! $make_command ]] && \
-	    make_command="make -C $kernel_source_dir M=$dkms_tree/$module/$module_version/build"
-	 [[ ! $clean ]] && \
-	     clean="make -C $kernel_source_dir M=$dkms_tree/$module/$module_version/build clean"
+        [[ ! $make_command ]] && make_command="make -C $kernel_source_dir M=$dkms_tree/$module/$module_version/build"
+        [[ ! $clean ]] && clean="make -C $kernel_source_dir M=$dkms_tree/$module/$module_version/build clean"
     fi
 
     # Set modules_conf_array
     for ((index=0; index < ${#MODULES_CONF[@]}; index++)); do
-	[[ ${MODULES_CONF[$index]} ]] && modules_conf_array[$index]="${MODULES_CONF[$index]}"
+        [[ ${MODULES_CONF[$index]} ]] && modules_conf_array[$index]="${MODULES_CONF[$index]}"
     done
 
     # Set patch_array (including kernel specific patches)
     count=0
     for ((index=0; index < ${#PATCH[@]}; index++)); do
-	if [[ ${PATCH[$index]} && (! ${PATCH_MATCH[$index]} || \
-		$1 =~ ${PATCH_MATCH[$index]}) ]]; then
-	    patch_array[$count]="${PATCH[$index]}"
-	    count=$(($count+1))
-	fi
+    if [[ ${PATCH[$index]} && (! ${PATCH_MATCH[$index]} || $1 =~ ${PATCH_MATCH[$index]}) ]]; then
+        patch_array[$count]="${PATCH[$index]}"
+        count=$(($count+1))
+    fi
     done
 
     # Set remake_initrd
     [[ $REMAKE_INITRD =~ $y_re ]] && remake_initrd="yes"
 
     # Set build_exclude
-    [[ $BUILD_EXCLUSIVE_KERNEL && ! $1 =~ $BUILD_EXCLUSIVE_KERNEL ]] && \
-       build_exclude="yes"
-    [[ $BUILD_EXCLUSIVE_ARCH && ! $2 =~ $BUILD_EXCLUSIVE_ARCH ]] && \
-	build_exclude="yes"
+    [[ $BUILD_EXCLUSIVE_KERNEL && ! $1 =~ $BUILD_EXCLUSIVE_KERNEL ]] && build_exclude="yes"
+    [[ $BUILD_EXCLUSIVE_ARCH && ! $2 =~ $BUILD_EXCLUSIVE_ARCH ]] && build_exclude="yes"
 
     # Fail if absolutely no DEST_MODULE_LOCATION
     if ((${#dest_module_location[@]} == 0)); then
-	echo $"dkms.conf: Error! No 'DEST_MODULE_LOCATION' directive specified." >&2
-	return_value=1
+        echo $"dkms.conf: Error! No 'DEST_MODULE_LOCATION' directive specified." >&2
+        return_value=1
     fi
 
     # Fail if no PACKAGE_NAME
     if [[ ! $package_name ]]; then
-	echo $"dkms.conf: Error! No 'PACKAGE_NAME' directive specified.">&2
-	return_value=1
+        echo $"dkms.conf: Error! No 'PACKAGE_NAME' directive specified.">&2
+        return_value=1
     fi
 
     # Fail if no PACKAGE_VERSION
     if [[ ! $package_version ]]; then
-	echo $"dkms.conf: Error! No 'PACKAGE_VERSION' directive specified.">&2
-	return_value=1
+        echo $"dkms.conf: Error! No 'PACKAGE_VERSION' directive specified.">&2
+        return_value=1
     fi
 
     # Set clean
     [[ $clean ]] || clean="make clean"
 
-    ((return_value == 0)) && last_mvka="$module/$module_version/$1/$2" && \
-	last_mvka_conf="$(readlink -f "$read_conf_file")"
+    ((return_value == 0)) && last_mvka="$module/$module_version/$1/$2" && last_mvka_conf="$(readlink -f "$read_conf_file")"
     return $return_value
 }
 
@@ -660,10 +697,15 @@ get_module_verinfo(){
     unset res
     local vals=
     while read -a vals; do
-	case ${vals[0]} in
-	    version:) res[0]=${vals[1]}; res[2]=${vals[2]};;
-	    srcversion:) res[1]=${vals[1]};;
-	esac
+    case ${vals[0]} in
+        version:)
+            res[0]=${vals[1]}
+            res[2]=${vals[2]}
+            ;;
+        srcversion:)
+        res[1]=${vals[1]}
+        ;;
+    esac
     done < <(modinfo $1)
 }
 
@@ -684,67 +726,65 @@ check_version_sanity()
     read -a kernels_module < <(find $lib_tree -name ${4}$module_suffix)
     [[ $kernels_module ]] || return 0
     if [[ ${kernels_module[1]} ]]; then
-	warn $"Warning! Cannot do version sanity checking because multiple ${4}$module_suffix" \
-	    $"modules were found in kernel $1."
-	return 0
+        warn $"Warning! Cannot do version sanity checking because multiple ${4}$module_suffix" \
+            $"modules were found in kernel $1."
+        return 0
     fi
     local dkms_module="$dkms_tree/$module/$module_version/$1/$2/module/${4}$module_suffix"
     get_module_verinfo $kernels_module; kernels_info=("${res[@]}")
     get_module_verinfo $dkms_module; dkms_info=("${res[@]}")
     if [[ ! ${dkms_info[1]} && ${kernels_info[1]} ]]; then
-	# use obsolete checksum info
-	dkms_info[1]=${dkms_info[2]}
-	kernels_info[1]=${kernels_info[2]}
+        # Use obsolete checksum info
+        dkms_info[1]=${dkms_info[2]}
+        kernels_info[1]=${kernels_info[2]}
     fi
 
-    if [[ ${kernels_info[1]} && ${dkms_info[1]} && \
-	${kernels_info[1]} = ${dkms_info[1]} && ! $force ]]; then
-	echo $"" >&2
-	echo $"Good news! Module version $dkms_info for ${4}$module_suffix" >&2
-	echo $"exactly matches what is already found in kernel $1." >&2
-	echo $"DKMS will not replace this module." >&2
-	echo $"You may override by specifying --force." >&2
-	return 1
+    if [[ ${kernels_info[1]} && ${dkms_info[1]} && ${kernels_info[1]} = ${dkms_info[1]} && ! $force ]]; then
+        echo $"" >&2
+        echo $"Good news! Module version $dkms_info for ${4}$module_suffix" >&2
+        echo $"exactly matches what is already found in kernel $1." >&2
+        echo $"DKMS will not replace this module." >&2
+        echo $"You may override by specifying --force." >&2
+        return 1
     fi
 
-    if [[ $kernels_info && $dkms_info && \
-	! ( $(VER $dkms_info) > $(VER $kernels_info) ) && ! $force ]]; then
-	error $"Module version $dkms_info for ${4}$module_suffix" \
-	    $"is not newer than what is already found in kernel $1 ($kernels_info)." \
-	    $"You may override by specifying --force."
-	return 1
+    if [[ $kernels_info && $dkms_info && ! ( $(VER $dkms_info) > $(VER $kernels_info) ) && ! $force ]]; then
+        error $"Module version $dkms_info for ${4}$module_suffix" \
+            $"is not newer than what is already found in kernel $1 ($kernels_info)." \
+            $"You may override by specifying --force."
+        return 1
     fi
 
-    # magic split into array syntax saves trivial awk and cut calls.
+    # Magic split into array syntax saves trivial awk and cut calls.
     local -a obs=(${3//-/ })
     local -a my=(${1//-/ })
     local obsolete=0
     if [[ ${obs} && ${my} ]]; then
-	if [[ $(VER ${obs}) == $(VER ${my}) && ! $force ]]; then
-	    #they get obsoleted possibly in this kernel release
-	    if [[ ! ${obs[1]} ]]; then
-		#they were obsoleted in this upstream kernel
-		obsolete=1
-	    elif [[ $(VER ${my[1]}) > $(VER ${obs[1]}) ]]; then
-		#they were obsoleted in an earlier ABI bump of the kernel
-		obsolete=1
-	    elif [[ $(VER ${my[1]}) = $(VER ${obs[1]}) ]]; then
-		#they were obsoleted in this ABI bump of the kernel
-		obsolete=1
-	    fi
-	elif [[ $(VER ${my}) > $(VER ${obs}) && ! $force ]]; then
-	    #they were obsoleted in an earlier kernel release
-	    obsolete=1
-	fi
+        if [[ $(VER ${obs}) == $(VER ${my}) && ! $force ]]; then
+            # They get obsoleted possibly in this kernel release
+            if [[ ! ${obs[1]} ]]; then
+                # They were obsoleted in this upstream kernel
+                obsolete=1
+            elif [[ $(VER ${my[1]}) > $(VER ${obs[1]}) ]]; then
+                # They were obsoleted in an earlier ABI bump of the kernel
+                obsolete=1
+            elif [[ $(VER ${my[1]}) = $(VER ${obs[1]}) ]]; then
+                # They were obsoleted in this ABI bump of the kernel
+                obsolete=1
+            fi
+        elif [[ $(VER ${my}) > $(VER ${obs}) && ! $force ]]; then
+            # They were obsoleted in an earlier kernel release
+            obsolete=1
+        fi
     fi
 
     if ((obsolete == 1)); then
-	echo $"" >&2
-	echo $"Module has been obsoleted due to being included" >&2
-	echo $"in kernel $3.  We will avoid installing" >&2
-	echo $"for future kernels above $3." >&2
-	echo $"You may override by specifying --force." >&2
-	return 1
+        echo $"" >&2
+        echo $"Module has been obsoleted due to being included" >&2
+        echo $"in kernel $3.  We will avoid installing" >&2
+        echo $"for future kernels above $3." >&2
+        echo $"You may override by specifying --force." >&2
+        return 1
     fi
     return 0
 }
@@ -752,36 +792,36 @@ check_version_sanity()
 moduleconfig_update_obsoletes()
 {
     # $@ = files to process
-    # do nothing if we have no obsoletes
+    # Do nothing if we have no obsoletes
     ( IFS=; [[ "${modules_conf_obsoletes[*]}" ]] ) || return 0
-    # generate sed args to remove obsolete modules
+    # Generate sed args to remove obsolete modules
     local mod_diff
     for ((index=0; index < ${#dest_module_name[@]}; index++)); do
-	[[ ${modules_conf_obsoletes[$index]} ]] || continue
-	for obsolete_module in ${modules_conf_obsoletes[$index]//,/ }; do
-	    # for module.conf style syntax
-	    sa_mc_o[${#sa_mc_o[*]}]="-e"
-	    sa_mc_o[${#sa_mc_o[*]}]="s/\(alias ${modules_conf_alias_type[$index]}[0-9]*\) $obsolete_module$/\1 ${dest_module_name[$index]}/g"
-	    # for /etc/sysconfig/kernel style syntax
-	    sa_sck_o[${#sa_sck_o[*]}]="-e"
-	    sa_sck_o[${#sa_sck_o[*]}]="s/\(INITRD_MODULES.*\)$obsolete_module\b\(.*\)/\1${dest_module_name[$index]}\2/"
-	done
+        [[ ${modules_conf_obsoletes[$index]} ]] || continue
+        for obsolete_module in ${modules_conf_obsoletes[$index]//,/ }; do
+            # For module.conf style syntax
+            sa_mc_o[${#sa_mc_o[*]}]="-e"
+            sa_mc_o[${#sa_mc_o[*]}]="s/\(alias ${modules_conf_alias_type[$index]}[0-9]*\) $obsolete_module$/\1 ${dest_module_name[$index]}/g"
+            # For /etc/sysconfig/kernel style syntax
+            sa_sck_o[${#sa_sck_o[*]}]="-e"
+            sa_sck_o[${#sa_sck_o[*]}]="s/\(INITRD_MODULES.*\)$obsolete_module\b\(.*\)/\1${dest_module_name[$index]}\2/"
+        done
     done
 
-    # do all the changes at once, record the diffs for posterity
+    # Do all the changes at once, record the diffs for posterity
     for file in "$@"; do
-	[[ $file && -w $file ]] || continue
-	if [[ $file = /etc/sysconfig/kernel ]]; then
-	    sed "${sa_sck_o[*]}" "$file" > "$temp_dir_name/${file##*/}.new"
-	else
-	    sed "${sa_mc_o[*]}" "$file" > "$temp_dir_name/${file##*/}.new"
-	fi
-	if ! mod_diff=$(diff -u "$temp_dir_name/${file##*/}.new" "$file"); then
-	    echo $"$file updated to replace obsoleted module references:"
-	    echo "$mod_diff"
-	    cp -fp "$temp_dir_name/${file##*/}.new" "$file"
-	    rm -f "$temp_dir_name/${file##*/}.new"
-	fi
+        [[ $file && -w $file ]] || continue
+        if [[ $file = /etc/sysconfig/kernel ]]; then
+            sed "${sa_sck_o[*]}" "$file" > "$temp_dir_name/${file##*/}.new"
+        else
+            sed "${sa_mc_o[*]}" "$file" > "$temp_dir_name/${file##*/}.new"
+        fi
+        if ! mod_diff=$(diff -u "$temp_dir_name/${file##*/}.new" "$file"); then
+            echo $"$file updated to replace obsoleted module references:"
+            echo "$mod_diff"
+            cp -fp "$temp_dir_name/${file##*/}.new" "$file"
+            rm -f "$temp_dir_name/${file##*/}.new"
+        fi
     done
 }
 
@@ -792,46 +832,45 @@ moduleconfig_add()
     local temp_dir_name=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
     local -a sa_mc_o=() sa_sck_o=()
     modconfig_files="/etc/modprobe.d/dkms.conf
-		     /etc/modprobe.d/dkms
-		     /etc/modules.conf
-		     /etc/modprobe.conf
-		     /etc/modprobe.d/$package_name.conf
-		     /etc/sysconfig/kernel"
+        /etc/modprobe.d/dkms
+        /etc/modules.conf
+        /etc/modprobe.conf
+        /etc/modprobe.d/$package_name.conf
+        /etc/sysconfig/kernel"
 
     moduleconfig_update_obsoletes $modconfig_files
 
     for moduleconfig in $modconfig_files; do
-	[[ -e $moduleconfig ]] || continue
-	for ((index=0; index < ${#dest_module_name[@]}; index++)); do
-
-	    # Only add it if it can't be found already in config file
-	    if [[ ${modules_conf_alias_type[$index]} ]] && \
-	       ! grep -qs "alias ${modules_conf_alias_type[$index]}[0-9]* ${dest_module_name[$index]}\b" $moduleconfig && \
-	       [[ ${modules_conf_obsolete_only[$index]} != yes ]]; then
-		if [[ $modconfig_files = /etc/modprobe.d/$package_name.conf ]] && \
-		    [[ ! -e /etc/modprobe.d/$package_name.conf ]]; then
-		    touch /etc/modprobe.d/$package_name.conf
-		    echo $"created /etc/modprobe.d/$package_name.conf.">&2
-		fi
-		aliases=$(awk "/^alias ${modules_conf_alias_type[$index]}/ {print \$2}" $moduleconfig)
-		if [[ $aliases ]]; then
-		    alias_number=$(($(echo "$aliases" | sed "s/${modules_conf_alias_type[$index]}//" | sort -n | tail -n 1) + 1))
-		else
-		    alias_number=0
-		fi
-		echo -e "alias ${modules_conf_alias_type[$index]}${alias_number} ${dest_module_name[$index]}" >> $moduleconfig
-		echo $"$moduleconfig: added alias reference for '${dest_module_name[$index]}'"
-	    fi
-	done
-
-	# Add anything else
-	for ((index=0; index < ${#modules_conf_array[@]}; index++)); do
-	    if [ -n "${modules_conf_array[$index]}" ] && \
-	    ! grep -q "${modules_conf_array[$index]}" "$moduleconfig"; then
-	    echo -e $"$moduleconfig: added '${modules_conf_array[$index]}'"
-	    echo -e "${modules_conf_array[$index]}" >> $moduleconfig
-	    fi
-	done
+    [[ -e $moduleconfig ]] || continue
+    for ((index=0; index < ${#dest_module_name[@]}; index++)); do
+
+        # Only add it if it can't be found already in config file
+        if [[ ${modules_conf_alias_type[$index]} ]] && \
+           ! grep -qs "alias ${modules_conf_alias_type[$index]}[0-9]* ${dest_module_name[$index]}\b" $moduleconfig && \
+           [[ ${modules_conf_obsolete_only[$index]} != yes ]]; then
+            if [[ $modconfig_files = /etc/modprobe.d/$package_name.conf ]] && [[ ! -e /etc/modprobe.d/$package_name.conf ]]; then
+                touch /etc/modprobe.d/$package_name.conf
+                echo $"created /etc/modprobe.d/$package_name.conf.">&2
+            fi
+            aliases=$(awk "/^alias ${modules_conf_alias_type[$index]}/ {print \$2}" $moduleconfig)
+            if [[ $aliases ]]; then
+                alias_number=$(($(echo "$aliases" | sed "s/${modules_conf_alias_type[$index]}//" | sort -n | tail -n 1) + 1))
+            else
+                alias_number=0
+            fi
+            echo -e "alias ${modules_conf_alias_type[$index]}${alias_number} ${dest_module_name[$index]}" >> $moduleconfig
+            echo $"$moduleconfig: added alias reference for '${dest_module_name[$index]}'"
+        fi
+    done
+
+    # Add anything else
+    for ((index=0; index < ${#modules_conf_array[@]}; index++)); do
+        if [ -n "${modules_conf_array[$index]}" ] && \
+        ! grep -q "${modules_conf_array[$index]}" "$moduleconfig"; then
+        echo -e $"$moduleconfig: added '${modules_conf_array[$index]}'"
+        echo -e "${modules_conf_array[$index]}" >> $moduleconfig
+        fi
+    done
     done
 
     # Delete the temp dir
@@ -851,40 +890,41 @@ moduleconfig_remove()
     [ -e /etc/modprobe.d/$package_name.conf ] && modconfig_files="/etc/modprobe.d/$package_name.conf"
 
     for moduleconfig in $modconfig_files; do
-	for ((index=0; index < ${#dest_module_name[@]}; index++)); do
-	    # Remove/Replace aliases (maybe)
-	    [[ ${modules_conf_alias_type[$index]} ]] || continue
-	    find "$install_tree/$1/" -name "${dest_module_name[$index]}.*" -quit 2>/dev/null && continue
-
-	    local conf_replacement=""
-	    for obsolete_module in ${modules_conf_obsoletes[$index]//,/ }; do
-		find $install_tree/$1/ -name "$obsolete_module.*" -quit 2>/dev/null || continue
-		conf_replacement=$obsolete_module
-		break
-	    done
-
-	    if [[ ! $conf_replacement ]]; then
-		grep -v "alias ${modules_conf_alias_type[$index]}[0-9]* ${dest_module_name[$index]}" $moduleconfig > $temp_dir_name/moduleconfig.new
-		mv -f $temp_dir_name/moduleconfig.new $moduleconfig
-		echo $"$moduleconfig: removed alias for '${dest_module_name[$index]}'"
-		if [[ $modconfig_files = /etc/modprobe.d/$package_name.conf ]]; then
-		    rm -f /etc/modprobe.d/$package_name.conf
-		    echo $"$moduleconfig: deleted /etc/modprobe.d/$package_name.conf file"
-		fi
-	    elif grep -q "alias ${modules_conf_alias_type[$index]}[0-9]* ${dest_module_name[$index]}$" $moduleconfig; then
-		sed "s/\(alias ${modules_conf_alias_type[$index]}[0-9]*\) ${dest_module_name[$index]}$/\1 $conf_replacement/g" $moduleconfig > $temp_dir_name/moduleconfig.new
-		mv -f $temp_dir_name/moduleconfig.new $moduleconfig
-		echo $"$moduleconfig: alias for '${dest_module_name[$index]}' changed back to '$conf_replacement'"
-	    fi
-	done
-
-	# Remove static conf entries
-	for ((index=0; index < ${#modules_conf_array[@]}; index++)); do
-	    [[ ${modules_conf_array[$index]} ]] || continue
-	    grep -v "${modules_conf_array[$index]}" "$moduleconfig" > $temp_dir_name/moduleconfig.new
-	    echo $"$moduleconfig: removed '${modules_conf_array[$index]}'"
-	    mv -f $temp_dir_name/moduleconfig.new $moduleconfig
-	done
+        for ((index=0; index < ${#dest_module_name[@]}; index++)); do
+            # Remove/Replace aliases (maybe)
+            [[ ${modules_conf_alias_type[$index]} ]] || continue
+            find "$install_tree/$1/" -name "${dest_module_name[$index]}.*" -quit 2>/dev/null && continue
+
+            local conf_replacement=""
+            for obsolete_module in ${modules_conf_obsoletes[$index]//,/ }; do
+                find $install_tree/$1/ -name "$obsolete_module.*" -quit 2>/dev/null || continue
+                conf_replacement=$obsolete_module
+                break
+            done
+
+            if [[ ! $conf_replacement ]]; then
+                grep -v "alias ${modules_conf_alias_type[$index]}[0-9]* ${dest_module_name[$index]}" $moduleconfig > $temp_dir_name/moduleconfig.new
+                mv -f $temp_dir_name/moduleconfig.new $moduleconfig
+                echo $"$moduleconfig: removed alias for '${dest_module_name[$index]}'"
+                if [[ $modconfig_files = /etc/modprobe.d/$package_name.conf ]]; then
+                    rm -f /etc/modprobe.d/$package_name.conf
+                    echo $"$moduleconfig: deleted /etc/modprobe.d/$package_name.conf file"
+                fi
+                elif grep -q "alias ${modules_conf_alias_type[$index]}[0-9]* ${dest_module_name[$index]}$" $moduleconfig; then
+                    sed "s/\(alias ${modules_conf_alias_type[$index]}[0-9]*\) ${dest_module_name[$index]}$/\1 $conf_replacement/g" \
+                        $moduleconfig > $temp_dir_name/moduleconfig.new
+                    mv -f $temp_dir_name/moduleconfig.new $moduleconfig
+                    echo $"$moduleconfig: alias for '${dest_module_name[$index]}' changed back to '$conf_replacement'"
+            fi
+        done
+
+        # Remove static conf entries
+        for ((index=0; index < ${#modules_conf_array[@]}; index++)); do
+            [[ ${modules_conf_array[$index]} ]] || continue
+            grep -v "${modules_conf_array[$index]}" "$moduleconfig" > $temp_dir_name/moduleconfig.new
+            echo $"$moduleconfig: removed '${modules_conf_array[$index]}'"
+            mv -f $temp_dir_name/moduleconfig.new $moduleconfig
+        done
     done
 
     # Delete the temp dir
@@ -898,20 +938,20 @@ etc_sysconfig_kernel_modify()
     # Make a temp directory to store files
     local temp_dir_name=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
     if [[ $1 = add ]]; then
-	. /etc/sysconfig/kernel
-	for m in "${dest_module_name[@]}"; do
-	    for l in "${INITRD_MODULES}"; do
-		[[ $m = $l ]] && continue 2
-	    done
-	    sed -e "s/INITRD_MODULES=\"\(.*\)\"/INITRD_MODULES=\"\1 $m\"/" /etc/sysconfig/kernel > $temp_dir_name/kernel.new
-	    mv $temp_dir_name/kernel.new /etc/sysconfig/kernel
-	done
+        . /etc/sysconfig/kernel
+        for m in "${dest_module_name[@]}"; do
+            for l in "${INITRD_MODULES}"; do
+                [[ $m = $l ]] && continue 2
+            done
+            sed -e "s/INITRD_MODULES=\"\(.*\)\"/INITRD_MODULES=\"\1 $m\"/" /etc/sysconfig/kernel > $temp_dir_name/kernel.new
+            mv $temp_dir_name/kernel.new /etc/sysconfig/kernel
+        done
     # Remove /etc/sysconfig/kernel entries
     elif [[ $1 = delete ]]; then
-	for m in "${dest_module_name[@]}"; do
-	    sed -e "s/\(INITRD_MODULES.*\)$m\b\(.*\)/\1\2/" /etc/sysconfig/kernel > $temp_dir_name/kernel.new
-	    mv $temp_dir_name/kernel.new /etc/sysconfig/kernel
-	done
+        for m in "${dest_module_name[@]}"; do
+            sed -e "s/\(INITRD_MODULES.*\)$m\b\(.*\)/\1\2/" /etc/sysconfig/kernel > $temp_dir_name/kernel.new
+            mv $temp_dir_name/kernel.new /etc/sysconfig/kernel
+        done
     fi
     # Delete the temp dir
     rm -rf $temp_dir_name
@@ -922,13 +962,13 @@ check_module_args() {
     die 1 $"Invalid number of arguments passed." \
         $"Usage: $1 <module>/<module-version> or" \
         $"       $1 -m <module>/<module-version> or" \
-	$"       $1 -m <module> -v <module-version>"
+        $"       $1 -m <module> -v <module-version>"
 }
 
 read_conf_or_die() {
     read_conf "$@" && return
     die 8 $"Bad conf file." $"File: $conf" \
-	$"does not represent a valid dkms.conf file."
+        $"does not represent a valid dkms.conf file."
 }
 
 run_build_script() {
@@ -937,8 +977,12 @@ run_build_script() {
     local script_type run
     [[ $2 ]] || return 0
     case "$1" in
-        pre_build|post_build) script_type='build';;
-        *) script_type='source'
+        pre_build|post_build)
+            script_type='build'
+            ;;
+        *)
+            script_type='source'
+            ;;
     esac
     run="$dkms_tree/$module/$module_version/$script_type/$2"
     if [[ -x ${run%% *} ]]; then
@@ -960,12 +1004,12 @@ run_build_script() {
 # being unpacked into /usr/src/$module-$module_version.
 add_module()
 {
-    # if $archive is set and $module and $module_version are not,
+    # If $archive is set and $module and $module_version are not,
     # try loading the tarball passed first.
     if [[ $archive_location && ! $module && ! $module_version ]]; then
-	load_tarball
+        load_tarball
     elif [[ $try_source_tree && ! $module && ! $module_version ]]; then
-	add_source_tree "$try_source_tree"
+        add_source_tree "$try_source_tree"
     fi
 
     # Check that we have all the arguments
@@ -973,24 +1017,24 @@ add_module()
 
     # Check that this module-version hasn't already been added
     if is_module_added "$module" "$module_version"; then
-	die 3 $"DKMS tree already contains: $module-$module_version" \
-	    $"You cannot add the same module/version combo more than once."
+        die 3 $"DKMS tree already contains: $module-$module_version" \
+            $"You cannot add the same module/version combo more than once."
     fi
 
     [[ $conf ]] || conf="$source_tree/$module-$module_version/dkms.conf"
 
     # Check that /usr/src/$module-$module_version exists
     if ! [[ -d $source_tree/$module-$module_version ]]; then
-	die 2 $"Could not find module source directory." \
-	    $"Directory: $source_tree/$module-$module_version does not exist."
+        die 2 $"Could not find module source directory." \
+            $"Directory: $source_tree/$module-$module_version does not exist."
     fi
 
     # Do stuff for --rpm_safe_upgrade
     if [[ $rpm_safe_upgrade ]]; then
-	local pppid=$(awk '/PPid:/ {print $2}' /proc/$PPID/status)
-	local lock_name=$(mktemp_or_die $tmp_location/dkms_rpm_safe_upgrade_lock.$pppid.XXXXXX)
-	echo "$module-$module_version" >> $lock_name
-	ps -o lstart --no-headers -p $pppid 2>/dev/null >> $lock_name
+        local pppid=$(awk '/PPid:/ {print $2}' /proc/$PPID/status)
+        local lock_name=$(mktemp_or_die $tmp_location/dkms_rpm_safe_upgrade_lock.$pppid.XXXXXX)
+        echo "$module-$module_version" >> $lock_name
+        ps -o lstart --no-headers -p $pppid 2>/dev/null >> $lock_name
     fi
 
     # Check the conf file for sanity
@@ -1022,26 +1066,29 @@ prepare_kernel()
 
     # Check that kernel-source exists
     _check_kernel_dir "$1" || {
-	case "$running_distribution" in
-	    Debian* | Ubuntu* )
-		die 1 $"Your kernel headers for kernel $1 cannot be found." \
-		    $"Please install the linux-headers-$1 package," \
-		    $"or use the --kernelsourcedir option to tell DKMS where it's located";;
-	    * ) die 1 echo $"Your kernel headers for kernel $1 cannot be found at" \
-		$"/lib/modules/$1/build or /lib/modules/$1/source."
-		$"You can use the --kernelsourcedir option to tell DKMS where it's located."
-	esac
+    case "$running_distribution" in
+        Debian* | Ubuntu* )
+            die 1 $"Your kernel headers for kernel $1 cannot be found." \
+                $"Please install the linux-headers-$1 package," \
+                $"or use the --kernelsourcedir option to tell DKMS where it's located"
+                ;;
+        * )
+            die 1 echo $"Your kernel headers for kernel $1 cannot be found at" \
+                $"/lib/modules/$1/build or /lib/modules/$1/source."
+                $"You can use the --kernelsourcedir option to tell DKMS where it's located."
+            ;;
+    esac
     }
 
     [[ $no_prepare_kernel ]] && return
 
     if [[ (! ( $(VER $1) < $(VER 2.6.5) ) || -d /etc/SuSEconfig) && \
-       -d "$kernel_source_dir" && \
-       -z "$ksourcedir_fromcli" ]]; then
-	echo $""
-	echo $"Kernel preparation unnecessary for this kernel.  Skipping..."
-	no_clean_kernel="no-clean-kernel"
-	return 1
+        -d "$kernel_source_dir" && \
+        -z "$ksourcedir_fromcli" ]]; then
+        echo $""
+        echo $"Kernel preparation unnecessary for this kernel.  Skipping..."
+        no_clean_kernel="no-clean-kernel"
+        return 1
     fi
 
     # Prepare kernel for module build
@@ -1050,101 +1097,103 @@ prepare_kernel()
     echo $"(This is not compiling a kernel, just preparing kernel symbols)"
     cd $kernel_source_dir
     [[ -r .config ]] && {
-	config_contents=$(cat .config)
-	echo $"Storing current .config to be restored when complete"
+        config_contents=$(cat .config)
+        echo $"Storing current .config to be restored when complete"
     }
 
     # Set kernel_config
     if [[ -e /etc/redhat-release || -e /etc/fedora-release ]]; then
-	# Note this also applies to VMware 3.x
-	if [[ -z $kernel_config && -d $kernel_source_dir/configs ]]; then
-	    local kernel_trunc=${1%%-*}
-	    # Try a .config specific to whatever kernel we are running
-	    if [[ $1 =~ $rh_kernels && \
-		-e $kernel_source_dir/configs/kernel-$kernel_trunc-$2-${BASH_REMATCH[1]}.config ]]; then
-		kernel_config="$kernel_source_dir/configs/kernel-$kernel_trunc-$2-${BASH_REMATCH[1]}.config"
-	    elif [[ -e $kernel_source_dir/configs/kernel-$kernel_trunc-$2.config ]]; then
-		# If that one does not exist, try a generic one.
-		kernel_config="$kernel_source_dir/configs/kernel-$kernel_trunc-$2.config"
-	    else
-		# If that does not exist, fall back to no config file
-		kernel_config=""
-	    fi
-	fi
-    elif [[ (-e /etc/SuSE-release || -d /etc/SuSEconfig) && \
-	-z $kernel_config && -d $kernel_source_dir/arch ]]; then
-	    local kernel_trunc=${1%%-*}
-	    case $2 in
-		i586|i686) config_arch="i386";;
-		*) config_arch=$2;;
-	    esac
-	    for config_type in default smp bigsmp; do
-		[[ $1 =~ $config_type ]] && kernel_config="$kernel_source_dir/arch/$config_arch/defconfig.$config_type"
-		[[ -e $kernel_config ]] || kernel_config=""
-	    done
-	    [[ $kernel_config ]] || kernel_config="$kernel_source_dir/arch/$config_arch/defconfig.default"
-	    [[ -e $kernel_config ]] || kernel_config=""
+    # Note this also applies to VMware 3.x
+    if [[ -z $kernel_config && -d $kernel_source_dir/configs ]]; then
+        local kernel_trunc=${1%%-*}
+        # Try a .config specific to whatever kernel we are running
+        if [[ $1 =~ $rh_kernels && -e $kernel_source_dir/configs/kernel-$kernel_trunc-$2-${BASH_REMATCH[1]}.config ]]; then
+            kernel_config="$kernel_source_dir/configs/kernel-$kernel_trunc-$2-${BASH_REMATCH[1]}.config"
+        elif [[ -e $kernel_source_dir/configs/kernel-$kernel_trunc-$2.config ]]; then
+            # If that one does not exist, try a generic one.
+            kernel_config="$kernel_source_dir/configs/kernel-$kernel_trunc-$2.config"
+        else
+            # If that does not exist, fall back to no config file
+            kernel_config=""
+        fi
+    fi
+    elif [[ (-e /etc/SuSE-release || -d /etc/SuSEconfig) && -z $kernel_config && -d $kernel_source_dir/arch ]]; then
+        local kernel_trunc=${1%%-*}
+        case $2 in
+            i586|i686)
+                config_arch="i386"
+                ;;
+            *)
+                config_arch=$2
+                ;;
+        esac
+        for config_type in default smp bigsmp; do
+            [[ $1 =~ $config_type ]] && kernel_config="$kernel_source_dir/arch/$config_arch/defconfig.$config_type"
+            [[ -e $kernel_config ]] || kernel_config=""
+        done
+        [[ $kernel_config ]] || kernel_config="$kernel_source_dir/arch/$config_arch/defconfig.default"
+        [[ -e $kernel_config ]] || kernel_config=""
     fi
 
     # Do preparation
     if [ -e /boot/vmlinuz.version.h ]; then
-	echo $"Running UnitedLinux preparation routine"
-	local kernel_config="/boot/vmlinuz.config"
-	invoke_command "make mrproper" "make mrproper" background
-	[[ $config_contents ]] && echo "$config_contents" > .config
-	invoke_command "cp /boot/vmlinuz.version.h include/linux/version.h" "using /boot/vmlinux.version.h"
-	invoke_command "cp -f $kernel_config .config" "using $kernel_config"
-	invoke_command "make KERNELRELEASE=$1 cloneconfig" "make cloneconfig" background
-	invoke_command "make CONFIG_MODVERSIONS=1 KERNELRELEASE=$1 dep" "make CONFIG_MODVERSIONS=1 dep" background
+        echo $"Running UnitedLinux preparation routine"
+        local kernel_config="/boot/vmlinuz.config"
+        invoke_command "make mrproper" "make mrproper" background
+        [[ $config_contents ]] && echo "$config_contents" > .config
+        invoke_command "cp /boot/vmlinuz.version.h include/linux/version.h" "using /boot/vmlinux.version.h"
+        invoke_command "cp -f $kernel_config .config" "using $kernel_config"
+        invoke_command "make KERNELRELEASE=$1 cloneconfig" "make cloneconfig" background
+        invoke_command "make CONFIG_MODVERSIONS=1 KERNELRELEASE=$1 dep" "make CONFIG_MODVERSIONS=1 dep" background
     elif grep -q rhconfig.h $kernel_source_dir/include/linux/{modversions,version}.h 2>/dev/null; then
-	echo $"Running Red Hat style preparation routine"
-	invoke_command "make clean" "make clean" background
-	[[ $config_contents ]] && echo "$config_contents" > .config
-
-	if [[ $kernel_config ]]; then
-	    echo $"using $kernel_config"
-	    cp -f "$kernel_config" .config
-	elif [[ -e .config ]]; then
-	    warn $"Using $kernel_source_dir/.config" \
-		$"(I hope this is the correct config for this kernel)"
-	else
-	    warn $"Cannot find a .config file to prepare your kernel with." \
-		$"Try using the --config option to specify where one can be found." \
-		$"Your build will likely fail because of this."
-	fi
-
-	# Hack to workaround broken tmp_include_depends for Red Hat
-	if grep -q "/usr/src/build" $kernel_source_dir/tmp_include_depends 2>/dev/null; then
-	    sed 's/\/usr\/src\/build\/.*\/install//g' $kernel_source_dir/tmp_include_depends > $kernel_source_dir/tmp_include_depends.new
-	    mv -f $kernel_source_dir/tmp_include_depends.new $kernel_source_dir/tmp_include_depends
-	fi
-
-	invoke_command "make KERNELRELEASE=$1 oldconfig" "make oldconfig" background
-	kerneldoth_contents=$(cat /boot/kernel.h 2>/dev/null)
-	invoke_command "/usr/lib/dkms/mkkerneldoth --kernelver $1 --targetarch $2 --output /boot/kernel.h" "running mkkerneldoth" background
+        echo $"Running Red Hat style preparation routine"
+        invoke_command "make clean" "make clean" background
+        [[ $config_contents ]] && echo "$config_contents" > .config
+
+        if [[ $kernel_config ]]; then
+            echo $"using $kernel_config"
+            cp -f "$kernel_config" .config
+        elif [[ -e .config ]]; then
+            warn $"Using $kernel_source_dir/.config" \
+                $"(I hope this is the correct config for this kernel)"
+        else
+            warn $"Cannot find a .config file to prepare your kernel with." \
+                $"Try using the --config option to specify where one can be found." \
+                $"Your build will likely fail because of this."
+        fi
+
+        # Hack to workaround broken tmp_include_depends for Red Hat
+        if grep -q "/usr/src/build" $kernel_source_dir/tmp_include_depends 2>/dev/null; then
+            sed 's/\/usr\/src\/build\/.*\/install//g' $kernel_source_dir/tmp_include_depends > $kernel_source_dir/tmp_include_depends.new
+            mv -f $kernel_source_dir/tmp_include_depends.new $kernel_source_dir/tmp_include_depends
+        fi
+
+        invoke_command "make KERNELRELEASE=$1 oldconfig" "make oldconfig" background
+        kerneldoth_contents=$(cat /boot/kernel.h 2>/dev/null)
+        invoke_command "/usr/lib/dkms/mkkerneldoth --kernelver $1 --targetarch $2 --output /boot/kernel.h" "running mkkerneldoth" background
     else
-	echo $"Running Generic preparation routine"
-	invoke_command "make mrproper" "make mrproper" background
-	[[ $config_contents ]] && echo "$config_contents" > .config
-
-	if [[ $kernel_config ]]; then
-	    echo $"using $kernel_config"
-	    cp -f "$kernel_config" .config
-	elif [[ -e .config ]]; then
-	    warn $"using $kernel_source_dir/.config" \
-		$"(I hope this is the correct config for this kernel)"
-	else
-	    warn $"Warning! Cannot find a .config file to prepare your kernel with." \
-		$"Try using the --config option to specify where one can be found." \
-		$"Your build will likely fail because of this."
-	fi
-
-	invoke_command "make KERNELRELEASE=$1 oldconfig" "make oldconfig" background
-	if [[ $(VER $1) < $(VER 2.5) ]]; then
-	    invoke_command "make KERNELRELEASE=$1 dep" "make dep" background
-	else
-	    invoke_command "make KERNELRELEASE=$1 prepare-all scripts" "make prepare-all" background
-	fi
+        echo $"Running Generic preparation routine"
+        invoke_command "make mrproper" "make mrproper" background
+        [[ $config_contents ]] && echo "$config_contents" > .config
+
+        if [[ $kernel_config ]]; then
+            echo $"using $kernel_config"
+            cp -f "$kernel_config" .config
+        elif [[ -e .config ]]; then
+            warn $"using $kernel_source_dir/.config" \
+                $"(I hope this is the correct config for this kernel)"
+        else
+            warn $"Warning! Cannot find a .config file to prepare your kernel with." \
+                $"Try using the --config option to specify where one can be found." \
+                $"Your build will likely fail because of this."
+        fi
+
+        invoke_command "make KERNELRELEASE=$1 oldconfig" "make oldconfig" background
+        if [[ $(VER $1) < $(VER 2.5) ]]; then
+            invoke_command "make KERNELRELEASE=$1 dep" "make dep" background
+        else
+            invoke_command "make KERNELRELEASE=$1 prepare-all scripts" "make prepare-all" background
+        fi
     fi
     cd - >/dev/null
 }
@@ -1163,9 +1212,9 @@ prepare_build()
 
     # Check that the module has not already been built for this kernel
     [[ -d $base_dir ]] && die 3 \
-	$"This module/version has already been built on: $kernelver" \
-	$"Directory: $base_dir" \
-	$"already exists.  Use the dkms remove function before trying to build again."
+        $"This module/version has already been built on: $kernelver" \
+        $"Directory: $base_dir" \
+        $"already exists.  Use the dkms remove function before trying to build again."
 
     # Read the conf file
     set_module_suffix "$kernelver"
@@ -1173,13 +1222,13 @@ prepare_build()
 
     # Error out if build_exclude is set
     [[ $build_exclude ]] && die 9 \
-	$" The dkms.conf for this module includes a BUILD_EXCLUSIVE directive which" \
-	$"does not match this kernel/arch.  This indicates that it should not be built."
+        $" The dkms.conf for this module includes a BUILD_EXCLUSIVE directive which" \
+        $"does not match this kernel/arch.  This indicates that it should not be built."
 
     # Error out if source_tree is basically empty (binary-only dkms tarball w/ --force check)
     (($(ls $dkms_tree/$module/$module_version/source | wc -l | awk {'print $1'}) < 2)) && die 8 \
-	$"The directory $dkms_tree/$module/$module_version/source/" \
-	$"does not appear to have module source located within it.  Build halted."
+        $"The directory $dkms_tree/$module/$module_version/source/" \
+        $"does not appear to have module source located within it.  Build halted."
 
     prepare_kernel "$kernelver" "$arch"
 
@@ -1191,13 +1240,13 @@ prepare_build()
 
     # Apply any patches
     for p in "${patch_array[@]}"; do
-	[[ ! -e $dkms_tree/$module/$module_version/build/patches/$p ]] && \
-	    report_build_problem 5 \
-	    $" Patch $p as specified in dkms.conf cannot be" \
-	    $"found in $dkms_tree/$module/$module_version/build/patches/."
-	invoke_command "patch -p1 < ./patches/$p" "applying patch $p" || \
-	    report_build_problem 6 $"Application of patch $p failed." \
-	    $"Check $dkms_tree/$module/$module_version/build/ for more information."
+        [[ ! -e $dkms_tree/$module/$module_version/build/patches/$p ]] && \
+            report_build_problem 5 \
+            $" Patch $p as specified in dkms.conf cannot be" \
+            $"found in $dkms_tree/$module/$module_version/build/patches/."
+        invoke_command "patch -p1 < ./patches/$p" "applying patch $p" || \
+            report_build_problem 6 $"Application of patch $p failed." \
+            $"Check $dkms_tree/$module/$module_version/build/ for more information."
     done
 
     # Run the pre_build script
@@ -1218,16 +1267,16 @@ do_build()
     local the_make_command="${make_command/#make/make KERNELRELEASE=$kernelver}"
 
     invoke_command "{ $the_make_command; } >> $dkms_tree/$module/$module_version/build/make.log 2>&1" "$the_make_command" background || \
-	report_build_problem 10 $"Bad return status for module build on kernel: $kernelver ($arch)" \
-	$"Consult $dkms_tree/$module/$module_version/build/make.log for more information."
+        report_build_problem 10 $"Bad return status for module build on kernel: $kernelver ($arch)" \
+        $"Consult $dkms_tree/$module/$module_version/build/make.log for more information."
 
     # Make sure all the modules built successfully
     for ((count=0; count < ${#built_module_name[@]}; count++)); do
-	[[ -e ${built_module_location[$count]}${built_module_name[$count]}$module_suffix ]] && continue
-	report_build_problem 7 \
-	    $" Build of ${built_module_name[$count]}$module_suffix failed for: $kernelver ($arch)" \
-	    $"Consult the make.log in the build directory" \
-	    $"$dkms_tree/$module/$module_version/build/ for more information."
+        [[ -e ${built_module_location[$count]}${built_module_name[$count]}$module_suffix ]] && continue
+        report_build_problem 7 \
+            $" Build of ${built_module_name[$count]}$module_suffix failed for: $kernelver ($arch)" \
+            $"Consult the make.log in the build directory" \
+            $"$dkms_tree/$module/$module_version/build/ for more information."
     done
     cd - >/dev/null
 
@@ -1239,8 +1288,9 @@ do_build()
     # Save a copy of the new module
     mkdir "$base_dir/module" >/dev/null
     for ((count=0; count < ${#built_module_name[@]}; count++)); do
-	[[ ${strip[$count]} != no ]] && strip -g "$dkms_tree/$module/$module_version/build/${built_module_location[$count]}${built_module_name[$count]}$module_suffix"
-	cp -f "$dkms_tree/$module/$module_version/build/${built_module_location[$count]}${built_module_name[$count]}$module_suffix" "$base_dir/module/${dest_module_name[$count]}$module_suffix" >/dev/null
+    [[ ${strip[$count]} != no ]] && strip -g "$dkms_tree/$module/$module_version/build/${built_module_location[$count]}${built_module_name[$count]}$module_suffix"
+    cp -f "$dkms_tree/$module/$module_version/build/${built_module_location[$count]}${built_module_name[$count]}$module_suffix" \
+        "$base_dir/module/${dest_module_name[$count]}$module_suffix" >/dev/null
     done
 
     # Run the post_build script
@@ -1259,13 +1309,13 @@ clean_build()
        -d $kernel_source_dir && \
        ! -h $kernel_source_dir && \
        ! $ksourcedir_fromcli ]]; then
-	echo $"Kernel cleanup unnecessary for this kernel.  Skipping..."
+        echo $"Kernel cleanup unnecessary for this kernel.  Skipping..."
     elif [[ ! $no_clean_kernel ]]; then
-	cd "$kernel_source_dir"
-	[[ $kerneldoth_contents ]] || invoke_command "make mrproper" "cleaning kernel tree (make mrproper)" background
-	[[ $config_contents ]] || echo "$config_contents" > .config
-	[[ $kerneldoth_contents ]] && echo "$kerneldoth_contents" > /boot/kernel.h
-	cd - >/dev/null
+        cd "$kernel_source_dir"
+        [[ $kerneldoth_contents ]] || invoke_command "make mrproper" "cleaning kernel tree (make mrproper)" background
+        [[ $config_contents ]] || echo "$config_contents" > .config
+        [[ $kerneldoth_contents ]] && echo "$kerneldoth_contents" > /boot/kernel.h
+        cd - >/dev/null
     fi
 
     # Clean the build directory
@@ -1322,18 +1372,18 @@ install_module()
 
     # Make sure that kernel exists to install into
     [[ -e $install_tree/$kernelver ]] || die 6 \
-	$"The directory $install_tree/$kernelver doesn't exist." \
-	$"You cannot install a module onto a non-existant kernel."
+        $"The directory $install_tree/$kernelver doesn't exist." \
+        $"You cannot install a module onto a non-existant kernel."
 
     # Read the conf file
     read_conf_or_die "$kernelver" "$arch"
 
     # Check that its not already installed (kernel symlink)
     is_module_installed "$module" "$module_version" "$kernelver" "$arch" && die 5 \
-	$"This module/version combo is already installed" \
-	$"for kernel: $kernelver ($arch)"
+        $"This module/version combo is already installed" \
+        $"for kernel: $kernelver ($arch)"
 
-    # if upgrading using rpm_safe_upgrade, go ahead and force the install
+    # If upgrading using rpm_safe_upgrade, go ahead and force the install
     # else we can wind up with the first half of an upgrade failing to install anything,
     # while the second half of the upgrade, the removal, then succeeds, leaving us with
     # nothing installed.
@@ -1343,85 +1393,86 @@ install_module()
     local lib_tree="$install_tree/$kernelver"
     local count
     for ((count=0; count < ${#built_module_name[@]}; count++)); do
-	echo $""
-	echo $"${dest_module_name[$count]}$module_suffix:"
-	# Check this version against what is already in the kernel
-	check_version_sanity "$kernelver" "$arch" \
-	    "$obsolete_by" "${dest_module_name[$count]}" || continue
-
-	if ((count == 0)) && ! run_build_script pre_install "$pre_install" && \
-	    ! [[ $force ]]; then
-	    die 101 $"pre_install failed, aborting install." \
-		$"You may override by specifying --force."
-	fi
-	local module_count=$(find $lib_tree -name ${dest_module_name[$count]}$module_suffix -type f | wc -l | awk {'print $1'})
-	echo $" - Original module"
-	if [[ -L $dkms_tree/$module/kernel-$kernelver-$arch && \
-	    -e $dkms_tree/$module/original_module/$kernelver/$arch/${dest_module_name[$count]}$module_suffix ]]; then
-	    echo $"   - An original module was already stored during a previous install"
-	elif ! [[ -L $dkms_tree/$module/kernel-$kernelver-$arch ]]; then
-	    local archive_pref1="$lib_tree/extra/${dest_module_name[$count]}$module_suffix"
-	    local archive_pref2="$lib_tree/updates/${dest_module_name[$count]}$module_suffix"
-	    local archive_pref3="$lib_tree${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix"
-	    local archive_pref4=""
-	    ((module_count == 1)) && archive_pref4=$(find $lib_tree -name ${dest_module_name[$count]}$module_suffix -type f)
-	    local original_module=""
-	    local found_orginal=""
-	    for original_module in $archive_pref1 $archive_pref2 $archive_pref3 $archive_pref4; do
-		[[ -f $original_module ]] || continue
-		case "$running_distribution" in
-		    Debian* | Ubuntu* ) ;;
-		    *)
-			echo $"   - Found $original_module"
-			echo $"   - Storing in $dkms_tree/$module/original_module/$kernelver/$arch/"
-			echo $"   - Archiving for uninstallation purposes"
-			mkdir -p "$dkms_tree/$module/original_module/$kernelver/$arch"
-			mv -f "$original_module" "$dkms_tree/$module/original_module/$kernelver/$arch/"
-			;;
-		esac
-		found_original="yes"
-		break
-	    done
-	    if [[ ! $found_original ]] && ((module_count > 1)); then
-		echo $"   - Multiple original modules exist but DKMS does not know which to pick"
-		echo $"   - Due to the confusion, none will be considered during a later uninstall"
-	    elif [[ ! $found_original ]]; then
-		echo $"   - No original module exists within this kernel"
-	    fi
-	else
-	    echo $"   - This kernel never originally had a module by this name"
-	fi
-
-	if ((module_count > 1)); then
-	    echo $" - Multiple same named modules!"
-	    echo $"   - $module_count named ${dest_module_name[$count]}$module_suffix in $lib_tree/"
-	    case "$running_distribution" in
-		Debian* | Ubuntu* ) ;;
-		*)
-		    echo $"   - All instances of this module will now be stored for reference purposes ONLY"
-		    echo $"   - Storing in $dkms_tree/$module/original_module/$kernelver/$arch/collisions/"
-		    ;;
-	    esac
-	    for module_dup in $(find $lib_tree -name ${dest_module_name[$count]}$module_suffix -type f); do
-		dup_tree="${module_dup#$lib_tree}";
-		dup_tree="${dup_tree/${dest_module_name[$count]}$module_suffix}"
-		case "$running_distribution" in
-		Debian* | Ubuntu* ) ;;
-		*)
-		   echo $"     - Stored $module_dup"
-		   mkdir -p "$dkms_tree/$module/original_module/$kernelver/$arch/collisions/$dup_tree"
-		   mv -f $module_dup "$dkms_tree/$module/original_module/$kernelver/$arch/collisions/$dup_tree"
-		   ;;
-		esac
-	    done
-	fi
-
-	# Copy module to its location
-	echo $" - Installation"
-	echo $"   - Installing to $install_tree/$kernelver${dest_module_location[$count]}/"
-	mkdir -p $install_tree/$kernelver${dest_module_location[$count]}
-	[[ $symlink_modules ]] && symlink="-s"
-	cp -f $symlink  "$base_dir/module/${dest_module_name[$count]}$module_suffix" "$install_tree/$kernelver${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix"
+    echo $""
+    echo $"${dest_module_name[$count]}$module_suffix:"
+    # Check this version against what is already in the kernel
+    check_version_sanity "$kernelver" "$arch" "$obsolete_by" "${dest_module_name[$count]}" || continue
+
+    if ((count == 0)) && ! run_build_script pre_install "$pre_install" && ! [[ $force ]]; then
+        die 101 $"pre_install failed, aborting install." \
+            $"You may override by specifying --force."
+    fi
+    local module_count=$(find $lib_tree -name ${dest_module_name[$count]}$module_suffix -type f | wc -l | awk {'print $1'})
+    echo $" - Original module"
+    if [[ -L $dkms_tree/$module/kernel-$kernelver-$arch && \
+        -e $dkms_tree/$module/original_module/$kernelver/$arch/${dest_module_name[$count]}$module_suffix ]]; then
+        echo $"   - An original module was already stored during a previous install"
+    elif ! [[ -L $dkms_tree/$module/kernel-$kernelver-$arch ]]; then
+        local archive_pref1="$lib_tree/extra/${dest_module_name[$count]}$module_suffix"
+        local archive_pref2="$lib_tree/updates/${dest_module_name[$count]}$module_suffix"
+        local archive_pref3="$lib_tree${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix"
+        local archive_pref4=""
+        ((module_count == 1)) && archive_pref4=$(find $lib_tree -name ${dest_module_name[$count]}$module_suffix -type f)
+        local original_module=""
+        local found_orginal=""
+        for original_module in $archive_pref1 $archive_pref2 $archive_pref3 $archive_pref4; do
+            [[ -f $original_module ]] || continue
+            case "$running_distribution" in
+                Debian* | Ubuntu* )
+                    ;;
+                *)
+                echo $"   - Found $original_module"
+                echo $"   - Storing in $dkms_tree/$module/original_module/$kernelver/$arch/"
+                echo $"   - Archiving for uninstallation purposes"
+                mkdir -p "$dkms_tree/$module/original_module/$kernelver/$arch"
+                mv -f "$original_module" "$dkms_tree/$module/original_module/$kernelver/$arch/"
+                ;;
+            esac
+            found_original="yes"
+            break
+        done
+        if [[ ! $found_original ]] && ((module_count > 1)); then
+            echo $"   - Multiple original modules exist but DKMS does not know which to pick"
+            echo $"   - Due to the confusion, none will be considered during a later uninstall"
+        elif [[ ! $found_original ]]; then
+            echo $"   - No original module exists within this kernel"
+        fi
+    else
+        echo $"   - This kernel never originally had a module by this name"
+    fi
+
+    if ((module_count > 1)); then
+        echo $" - Multiple same named modules!"
+        echo $"   - $module_count named ${dest_module_name[$count]}$module_suffix in $lib_tree/"
+        case "$running_distribution" in
+            Debian* | Ubuntu* )
+                ;;
+            *)
+                echo $"   - All instances of this module will now be stored for reference purposes ONLY"
+                echo $"   - Storing in $dkms_tree/$module/original_module/$kernelver/$arch/collisions/"
+                ;;
+        esac
+        for module_dup in $(find $lib_tree -name ${dest_module_name[$count]}$module_suffix -type f); do
+            dup_tree="${module_dup#$lib_tree}";
+            dup_tree="${dup_tree/${dest_module_name[$count]}$module_suffix}"
+            case "$running_distribution" in
+                Debian* | Ubuntu* )
+                    ;;
+                *)
+                   echo $"     - Stored $module_dup"
+                   mkdir -p "$dkms_tree/$module/original_module/$kernelver/$arch/collisions/$dup_tree"
+                   mv -f $module_dup "$dkms_tree/$module/original_module/$kernelver/$arch/collisions/$dup_tree"
+                   ;;
+            esac
+        done
+    fi
+
+    # Copy module to its location
+    echo $" - Installation"
+    echo $"   - Installing to $install_tree/$kernelver${dest_module_location[$count]}/"
+    mkdir -p $install_tree/$kernelver${dest_module_location[$count]}
+    [[ $symlink_modules ]] && symlink="-s"
+    cp -f $symlink  "$base_dir/module/${dest_module_name[$count]}$module_suffix" "$install_tree/$kernelver${dest_module_location[$count]}/${dest_module_name[$count]}$module_suffix"
 
     done
 
@@ -1429,10 +1480,10 @@ install_module()
     rm -f "$dkms_tree/$module/kernel-$kernelver-$arch" 2>/dev/null
     ln -s "$module_version/$kernelver/$arch" "$dkms_tree/$module/kernel-$kernelver-$arch" 2>/dev/null
 
-    # add to kabi-tracking
+    # Add to kabi-tracking
     if [[ ${weak_modules} ]]; then
-	echo $"Adding any weak-modules"
-	list_each_installed_module "$module" "$kernelver" "$arch" | ${weak_modules} ${weak_modules_no_initrd} --add-modules
+        echo $"Adding any weak-modules"
+        list_each_installed_module "$module" "$kernelver" "$arch" | ${weak_modules} ${weak_modules_no_initrd} --add-modules
     fi
 
     # Run the post_install script
@@ -1444,17 +1495,17 @@ install_module()
     etc_sysconfig_kernel_modify "add"
 
     invoke_command "do_depmod $kernelver" "depmod" background || {
-	do_uninstall "$kernelver" "$arch"
-	die 6 $"Problems with depmod detected.  Automatically uninstalling this module." \
-	    $"DKMS: Install Failed (depmod problems).  Module rolled back to built state."
-	    exit 6
+        do_uninstall "$kernelver" "$arch"
+        die 6 $"Problems with depmod detected.  Automatically uninstalling this module." \
+            $"DKMS: Install Failed (depmod problems).  Module rolled back to built state."
+            exit 6
     }
 
     # Do remake_initrd things (save old initrd)
     [[ $remake_initrd ]] && ! make_initrd "$kernelver" "$arch" && {
-	do_uninstall "$kernelver" "$arch"
-	die 7 $"Problems with mkinitrd detected.  Automatically uninstalling this module." \
-	    $"DKMS: Install Failed (mkinitrd problems).  Module rolled back to built state."
+        do_uninstall "$kernelver" "$arch"
+        die 7 $"Problems with mkinitrd detected.  Automatically uninstalling this module." \
+            $"DKMS: Install Failed (mkinitrd problems).  Module rolled back to built state."
     }
     echo $""
     echo $"DKMS: install completed."
@@ -1472,8 +1523,8 @@ list_each_installed_module()
     local count
     local real_dest_module_location
     for ((count=0; count < ${#built_module_name[@]}; count++)); do
-	real_dest_module_location="$(find_actual_dest_module_location $1 $count $2 $3)"
-	echo "$install_tree/$2${real_dest_module_location}/${dest_module_name[$count]}$module_suffix"
+        real_dest_module_location="$(find_actual_dest_module_location $1 $count $2 $3)"
+        echo "$install_tree/$2${real_dest_module_location}/${dest_module_name[$count]}$module_suffix"
     done
 }
 
@@ -1489,7 +1540,7 @@ is_module_built() {
     [[ -d $d/module ]] || return 1
     read_conf_or_die "$3" "$4" "$dkms_tree/$1/$2/source/dkms.conf"
     for m in "${dest_module_name[@]}"; do
-	[[ -f $d/module/$m.ko || -f $d/module/$m.o ]] || return 1
+        [[ -f $d/module/$m.ko || -f $d/module/$m.o ]] || return 1
     done
 }
 
@@ -1506,24 +1557,24 @@ is_module_installed() { is_module_built "$@" && _is_module_installed "$@"; }
 
 maybe_add_module() (
     is_module_added "$1" "$2" && {
-	echo $"Module $1/$2 already added."
-	return 0
+        echo $"Module $1/$2 already added."
+        return 0
     }
     module="$1" module_version="$2" add_module
 )
 
 maybe_build_module() (
     is_module_built "$1" "$2" "$3" "$4" && {
-	echo $"Module $1/$2 already built for kernel $3/4"
-	return 0
+        echo $"Module $1/$2 already built for kernel $3/4"
+        return 0
     }
     module="$1" module_version="$2" kernelver="$3" arch="$4" build_module
 )
 
 maybe_install_module() (
     is_module_installed "$1" "$2" "$3" "$4" && {
-	echo $"Module $1/$2 already installed on kernel $3/$4"
-	return 0
+        echo $"Module $1/$2 already installed on kernel $3/$4"
+        return 0
     }
     module="$1" module_version="$2" kernelver="$3" arch="$4" install_module
 )
@@ -1531,21 +1582,21 @@ maybe_install_module() (
 build_modules() {
     local i=0
     for ((i=0; i < ${#kernelver[@]}; i++)); do
-	maybe_build_module "$module" "$module_version" "${kernelver[$i]}" "${arch[$i]}"
+        maybe_build_module "$module" "$module_version" "${kernelver[$i]}" "${arch[$i]}"
     done
 }
 
 install_modules() {
     local i=0
     for ((i=0; i < ${#kernelver[@]}; i++)); do
-	maybe_install_module "$module" "$module_version" "${kernelver[$i]}" "${arch[$i]}"
+        maybe_install_module "$module" "$module_version" "${kernelver[$i]}" "${arch[$i]}"
     done
 }
 
 check_module_exists() {
     is_module_added "$module" "$module_version" && return
     die 2 $"DKMS tree does not contain: $module-$module_version" \
-	$"Build cannot continue without the proper tree."
+        $"Build cannot continue without the proper tree."
 }
 
 possible_dest_module_locations()
@@ -1577,11 +1628,11 @@ find_actual_dest_module_location()
     dkms_owned="${dkms_tree}/${module}/kernel-${kernelver}-${arch}/module/${dest_module_name[$count]}${module_suffix}"
 
     for l in $locations; do
-	installed="${install_tree}/${kernelver}${l}/${dest_module_name[${count}]}${module_suffix}"
-	if [[ -f ${installed} ]] && diff "${dkms_owned}" "${installed}" > /dev/null 2>&1; then
-	    echo "${l}"
-	    return 0
-	fi
+        installed="${install_tree}/${kernelver}${l}/${dest_module_name[${count}]}${module_suffix}"
+        if [[ -f ${installed} ]] && diff "${dkms_owned}" "${installed}" > /dev/null 2>&1; then
+            echo "${l}"
+            return 0
+        fi
     done
 
 }
@@ -1606,54 +1657,55 @@ do_uninstall()
     local kernel_symlink=$(readlink -f "$dkms_tree/$module/kernel-$1-$2")
     local real_dest_module_location
     if [[ $kernel_symlink = $dkms_tree/$module/$module_version/$1/$2 ]]; then
-	was_active="true"
-	echo $""
-	echo $"Status: Before uninstall, this module version was ACTIVE on this kernel."
-	# remove kabi-tracking if last instance removed
-	if [[ ${weak_modules} ]] && \
-	    (module_status_built $module $module_version |grep -q "installed"); then
-	    echo $"Removing any linked weak-modules"
-	    list_each_installed_module "$module" "$1" "$2" | ${weak_modules} ${weak_modules_no_initrd} --remove-modules
-	fi
-
-	for ((count=0; count < ${#built_module_name[@]}; count++)); do
-	    real_dest_module_location="$(find_actual_dest_module_location $module $count $1 $2)"
-	    echo $""
-	    echo $"${dest_module_name[$count]}$module_suffix:"
-	    echo $" - Uninstallation"
-	    echo $"   - Deleting from: $install_tree/$1${real_dest_module_location}/"
-	    rm -f "$install_tree/$1${real_dest_module_location}/${dest_module_name[$count]}$module_suffix"
-	    dir_to_remove="${real_dest_module_location#/}"
-	    while [ "${dir_to_remove}" != "${dir_to_remove#/}" ]; do dir_to_remove="${dir_to_remove#/}" ; done
-	    (cd "$install_tree/$1" && rmdir --parents --ignore-fail-on-non-empty "${dir_to_remove}" || true)
-	    echo $" - Original module"
-	    if [[ -e $dkms_tree/$module/original_module/$1/$2/${dest_module_name[$count]}$module_suffix ]]; then
-		case "$running_distribution" in
-		Debian* | Ubuntu* ) ;;
-		*)
-		    echo $"   - Archived original module found in the DKMS tree"
-		    echo $"   - Moving it to: $install_tree/$1${DEST_MODULE_LOCATION[$count]}/"
-		    mkdir -p "$install_tree/$1${DEST_MODULE_LOCATION[$count]}/"
-		    mv -f "$dkms_tree/$module/original_module/$1/$2/${dest_module_name[$count]}$module_suffix" \
-			"$install_tree/$1${DEST_MODULE_LOCATION[$count]}/" 2>/dev/null
-		    ;;
-		esac
-	    else
-		echo $"   - No original module was found for this module on this kernel."
-		echo $"   - Use the dkms install command to reinstall any previous module version."
-
-		# Remove modules_conf entries from /etc/modules.conf if remake_initrd is set or if this is last instance removed
-		if [[ $remake_initrd ]] || \
-		    (do_status $module $module_version | grep -q "installed"); then
-		    echo $""
-		    moduleconfig_remove "$1"
-		fi
-	    fi
-	done
-	rm -f "$dkms_tree/$module/kernel-$1-$2"
+        was_active="true"
+        echo $""
+        echo $"Status: Before uninstall, this module version was ACTIVE on this kernel."
+        # remove kabi-tracking if last instance removed
+        if [[ ${weak_modules} ]] && (module_status_built $module $module_version |grep -q "installed"); then
+            echo $"Removing any linked weak-modules"
+            list_each_installed_module "$module" "$1" "$2" | ${weak_modules} ${weak_modules_no_initrd} --remove-modules
+        fi
+
+    for ((count=0; count < ${#built_module_name[@]}; count++)); do
+        real_dest_module_location="$(find_actual_dest_module_location $module $count $1 $2)"
+        echo $""
+        echo $"${dest_module_name[$count]}$module_suffix:"
+        echo $" - Uninstallation"
+        echo $"   - Deleting from: $install_tree/$1${real_dest_module_location}/"
+        rm -f "$install_tree/$1${real_dest_module_location}/${dest_module_name[$count]}$module_suffix"
+        dir_to_remove="${real_dest_module_location#/}"
+        while [ "${dir_to_remove}" != "${dir_to_remove#/}" ]; do
+            dir_to_remove="${dir_to_remove#/}"
+        done
+        (cd "$install_tree/$1" && rmdir --parents --ignore-fail-on-non-empty "${dir_to_remove}" || true)
+        echo $" - Original module"
+        if [[ -e $dkms_tree/$module/original_module/$1/$2/${dest_module_name[$count]}$module_suffix ]]; then
+            case "$running_distribution" in
+                Debian* | Ubuntu* )
+                    ;;
+                *)
+                    echo $"   - Archived original module found in the DKMS tree"
+                    echo $"   - Moving it to: $install_tree/$1${DEST_MODULE_LOCATION[$count]}/"
+                    mkdir -p "$install_tree/$1${DEST_MODULE_LOCATION[$count]}/"
+                    mv -f "$dkms_tree/$module/original_module/$1/$2/${dest_module_name[$count]}$module_suffix" \
+                    "$install_tree/$1${DEST_MODULE_LOCATION[$count]}/" 2>/dev/null
+                    ;;
+            esac
+            else
+            echo $"   - No original module was found for this module on this kernel."
+            echo $"   - Use the dkms install command to reinstall any previous module version."
+
+            # Remove modules_conf entries from /etc/modules.conf if remake_initrd is set or if this is last instance removed
+            if [[ $remake_initrd ]] || (do_status $module $module_version | grep -q "installed"); then
+                echo $""
+                moduleconfig_remove "$1"
+            fi
+        fi
+    done
+    rm -f "$dkms_tree/$module/kernel-$1-$2"
     else
-	echo $""
-	echo $"Status: This module version was INACTIVE for this kernel."
+        echo $""
+        echo $"Status: This module version was INACTIVE for this kernel."
     fi
 
     # Run the post_remove script
@@ -1664,22 +1716,21 @@ do_uninstall()
 
     # Do remake_initrd things (remake initrd)
     if [[ $remake_initrd && $was_active ]] && ! make_initrd "$1" "$2"; then
-	warn $"There was a problem remaking your initrd.  You must manually remake it" \
-	    $"before booting into this kernel."
+        warn $"There was a problem remaking your initrd.  You must manually remake it" \
+            $"before booting into this kernel."
     fi
 
     # Delete the original_module if nothing for this kernel is installed anymore
-    if [[ $was_active && -d $dkms_tree/$module/original_module/$1/$2 && \
-	! -d $dkms_tree/$module/original_module/$1/$2/collisions ]]; then
-	echo $""
-	echo $"Removing original_module from DKMS tree for kernel $1 ($2)"
-	rm -rf "$dkms_tree/$module/original_module/$1/$2" 2>/dev/null
-	[[ $(find $dkms_tree/$module/original_module/$1/* -maxdepth 0 -type d 2>/dev/null) ]] || rm -rf "$dkms_tree/$module/original_module/$1"
+    if [[ $was_active && -d $dkms_tree/$module/original_module/$1/$2 && ! -d $dkms_tree/$module/original_module/$1/$2/collisions ]]; then
+        echo $""
+        echo $"Removing original_module from DKMS tree for kernel $1 ($2)"
+        rm -rf "$dkms_tree/$module/original_module/$1/$2" 2>/dev/null
+        [[ $(find $dkms_tree/$module/original_module/$1/* -maxdepth 0 -type d 2>/dev/null) ]] || rm -rf "$dkms_tree/$module/original_module/$1"
     elif [[ $was_active && -d $dkms_tree/$module/original_module/$1/$2/collisions ]]; then
-	echo $""
-	echo $"Keeping directory $dkms_tree/$module/original_module/$1/$2/collisions/"
-	echo $"for your reference purposes.  Your kernel originally contained multiple"
-	echo $"same-named modules and this directory is now where these are located."
+        echo $""
+        echo $"Keeping directory $dkms_tree/$module/original_module/$1/$2/collisions/"
+        echo $"for your reference purposes.  Your kernel originally contained multiple"
+        echo $"same-named modules and this directory is now where these are located."
     fi
     [[ $(find $dkms_tree/$module/original_module/* -maxdepth 0 -type d 2>/dev/null) ]] || rm -rf "$dkms_tree/$module/original_module"
 
@@ -1699,13 +1750,13 @@ uninstall_module()
 
     # Check that $module is in the dkms tree
     [[ -d $dkms_tree/$module ]] || die 2 \
-	$"There are no instances of module: $module" \
-	$"located in the DKMS tree."
+        $"There are no instances of module: $module" \
+        $"located in the DKMS tree."
 
     # Make sure that its installed in the first place
     [[ -d $dkms_tree/$module/$module_version ]] || die 3 \
-	$"The module/version combo: $module-$module_version" \
-	$"is not located in the DKMS tree."
+        $"The module/version combo: $module-$module_version" \
+        $"is not located in the DKMS tree."
 
     # Read the conf file
     read_conf_or_die "$kernelver" "$arch"
@@ -1713,8 +1764,8 @@ uninstall_module()
     # Only do stuff if module/module version is currently installed
     local kernel_symlink=$(readlink -f "$dkms_tree/$module/kernel-$kernelver-$arch")
     [[ $kernel_symlink = $dkms_tree/$module/$module_version/$kernelver/$arch ]] || die 5 \
-	    $"The module $module $module_version is not currently installed." \
-	    $"This module is not currently ACTIVE for kernel $kernelver ($arch)."
+        $"The module $module $module_version is not currently installed." \
+        $"This module is not currently ACTIVE for kernel $kernelver ($arch)."
     do_uninstall "$kernelver" "$arch"
 }
 
@@ -1723,68 +1774,67 @@ remove_module()
 {
     # Check that the right arguments were passed
     if [[ ! ($module && $module_version) || $kernels_arches_default  ]]; then
-	die 1 $"Invalid number of parameters passed." \
-	    $"Usage: remove <module>/<module-version> --all" \
-	    $"   or: remove <module>/<module-version> -k <kernel-version>"
+        die 1 $"Invalid number of parameters passed." \
+            $"Usage: remove <module>/<module-version> --all" \
+            $"   or: remove <module>/<module-version> -k <kernel-version>"
     fi
 
     # Check that $module is in the dkms tree
     if ! [[ -d $dkms_tree/$module/$module_version ]]; then
-	die 3 $"There are no instances of module: $module" \
-	    $"$module_version located in the DKMS tree."
+        die 3 $"There are no instances of module: $module" \
+            $"$module_version located in the DKMS tree."
     fi
 
     local i
     for ((i=0; i < ${#kernelver[@]}; i++)); do
-	# make sure its there first before removing
-	if ! [[ -d $dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]} ]]; then
-	    die 4 $"There is no instance of $module $module_version" \
-		$"for kernel ${kernelver[$i]} (${arch[$i]}) located in the DKMS tree."
-	fi
-
-	# Do --rpm_safe_upgrade check (exit out and don't do remove if inter-release RPM upgrade scenario occurs)
-	if [[ $rpm_safe_upgrade ]]; then
-	    local pppid=$(awk '/PPid:/ {print $2}' /proc/$PPID/status)
-	    local time_stamp=$(ps -o lstart --no-headers -p $pppid 2>/dev/null)
-	    for lock_file in $tmp_location/dkms_rpm_safe_upgrade_lock.$pppid.*; do
-		[[ -f $lock_file ]] || continue
-		lock_head=$(head -n 1 $lock_file 2>/dev/null)
-		lock_tail=$(tail -n 1 $lock_file 2>/dev/null)
-		[[ $lock_head = $module-$module_version && $time_stamp && $lock_tail = $time_stamp ]] || continue
-		rm -f $lock_file
-		die 0 $"DKMS: Remove cancelled because --rpm_safe_upgrade scenario detected."
-	    done
-	fi
-
-	# Read the conf file
-	read_conf_or_die "${kernelver[$i]}" "${arch[$i]}"
-
-	do_uninstall "${kernelver[$i]}" "${arch[$i]}"
-
-	# Delete the $kernel_version/$arch_used part of the tree
-	rm -rf "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}"
-	[[ $(find $dkms_tree/$module/$module_version/${kernelver[$i]}/* \
-	    -maxdepth 0 -type d 2>/dev/null) ]] || \
-	    rm -rf "$dkms_tree/$module/$module_version/${kernelver[$i]}"
+        # Make sure its there first before removing
+        if ! [[ -d $dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]} ]]; then
+            die 4 $"There is no instance of $module $module_version" \
+            $"for kernel ${kernelver[$i]} (${arch[$i]}) located in the DKMS tree."
+        fi
+
+        # Do --rpm_safe_upgrade check (exit out and don't do remove if inter-release RPM upgrade scenario occurs)
+        if [[ $rpm_safe_upgrade ]]; then
+            local pppid=$(awk '/PPid:/ {print $2}' /proc/$PPID/status)
+            local time_stamp=$(ps -o lstart --no-headers -p $pppid 2>/dev/null)
+            for lock_file in $tmp_location/dkms_rpm_safe_upgrade_lock.$pppid.*; do
+                [[ -f $lock_file ]] || continue
+                lock_head=$(head -n 1 $lock_file 2>/dev/null)
+                lock_tail=$(tail -n 1 $lock_file 2>/dev/null)
+                [[ $lock_head = $module-$module_version && $time_stamp && $lock_tail = $time_stamp ]] || continue
+                rm -f $lock_file
+                die 0 $"DKMS: Remove cancelled because --rpm_safe_upgrade scenario detected."
+            done
+        fi
+
+        # Read the conf file
+        read_conf_or_die "${kernelver[$i]}" "${arch[$i]}"
+
+        do_uninstall "${kernelver[$i]}" "${arch[$i]}"
+
+        # Delete the $kernel_version/$arch_used part of the tree
+        rm -rf "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}"
+        [[ $(find $dkms_tree/$module/$module_version/${kernelver[$i]}/* -maxdepth 0 -type d 2>/dev/null) ]] || \
+            rm -rf "$dkms_tree/$module/$module_version/${kernelver[$i]}"
     done
 
     # Delete the $module_version part of the tree if no other $module_version/$kernel_version dirs exist
     if ! find $dkms_tree/$module/$module_version/* -maxdepth 0 -type d 2>/dev/null | egrep -qv "(build|tarball|driver_disk|rpm|deb|source)$"; then
-	echo $""
-	echo $"------------------------------"
-	echo $"Deleting module version: $module_version"
-	echo $"completely from the DKMS tree."
-	echo $"------------------------------"
-	rm -rf "$dkms_tree/$module/$module_version"
-	echo $"Done."
+        echo $""
+        echo $"------------------------------"
+        echo $"Deleting module version: $module_version"
+        echo $"completely from the DKMS tree."
+        echo $"------------------------------"
+        rm -rf "$dkms_tree/$module/$module_version"
+        echo $"Done."
     fi
 
     # Get rid of any remnant directories if necessary
     if (($(ls "$dkms_tree/$module" | wc -w | awk '{print $1}') == 0)); then
-	rm -rf "$dkms_tree/$module" 2>/dev/null
+        rm -rf "$dkms_tree/$module" 2>/dev/null
 
-	# Its now safe to completely remove references in /etc/sysconfig/kernel for SuSE
-	etc_sysconfig_kernel_modify "delete"
+        # Its now safe to completely remove references in /etc/sysconfig/kernel for SuSE
+        etc_sysconfig_kernel_modify "delete"
     fi
 }
 
@@ -1797,13 +1847,13 @@ find_module_from_ko()
     local kernellink
 
     for kernellink in "$dkms_tree"/*/kernel-*; do
-	[[ -L $kernellink ]] || continue
-	module=${kernellink#$dkms_tree/}
-	module=${module%/kernel-*}
-	diff "$kernellink/module/${basename_ko}" "${ko}" >/dev/null 2>&1 || continue
-	rest=$(readlink $kernellink)
-	echo "$module/$rest"
-	return 0
+        [[ -L $kernellink ]] || continue
+        module=${kernellink#$dkms_tree/}
+        module=${module%/kernel-*}
+        diff "$kernellink/module/${basename_ko}" "${ko}" >/dev/null 2>&1 || continue
+        rest=$(readlink $kernellink)
+        echo "$module/$rest"
+        return 0
     done
     return 1
 }
@@ -1819,20 +1869,18 @@ module_status_weak() {
     local m v k a weak_ko mod installed_ko f ret=1 oifs=$IFS
     local -a already_found
     for weak_ko in "$install_tree/"*/weak-updates/*; do
-	[[ -e $weak_ko ]] || continue
-	[[ -L $weak_ko ]] && installed_ko="$(readlink -f "$weak_ko")" || continue
-	IFS=/ read m v k a < <(IFS=$oifs find_module_from_ko "$weak_ko") || continue
-	kern=${weak_ko#$install_tree/}
-	kern=${kern%/weak-updates/*}
-	[[ $m = ${1:-*} && $v = ${2:-*} && $k = ${5:-*} && \
-	    $a = ${4:-*} && $kern = ${3:-*} ]] || \
-	    continue
-	ret=0
-	for f in "${already_found[@]}"; do
-	    [[ $f = $m/$v/$kern/$a/$k ]] && continue 2
-	done
-	already_found[${#already_found[@]}]="$m/$v/$kern/$a/$k"
-	echo "installed-weak $m/$v/$kern/$a/$k"
+        [[ -e $weak_ko ]] || continue
+        [[ -L $weak_ko ]] && installed_ko="$(readlink -f "$weak_ko")" || continue
+        IFS=/ read m v k a < <(IFS=$oifs find_module_from_ko "$weak_ko") || continue
+        kern=${weak_ko#$install_tree/}
+        kern=${kern%/weak-updates/*}
+        [[ $m = ${1:-*} && $v = ${2:-*} && $k = ${5:-*} && $a = ${4:-*} && $kern = ${3:-*} ]] || continue
+        ret=0
+        for f in "${already_found[@]}"; do
+            [[ $f = $m/$v/$kern/$a/$k ]] && continue 2
+        done
+        already_found[${#already_found[@]}]="$m/$v/$kern/$a/$k"
+        echo "installed-weak $m/$v/$kern/$a/$k"
     done
     return $ret
 }
@@ -1842,8 +1890,8 @@ do_status_weak()
 {
     local mvka m v k a kern status
     while read status mvka; do
-	IFS=/ read m v k a kern <<< "$mvka"
-	echo "$m, $v, $k, $a: installed-weak from $kern"
+        IFS=/ read m v k a kern <<< "$mvka"
+        echo "$m, $v, $k, $a: installed-weak from $kern"
     done < <(module_status_weak "$@")
 }
 
@@ -1854,15 +1902,15 @@ module_status_built_extra() (
     read_conf "$3" "$4" "$dkms_tree/$1/$2/source/dkms.conf"
     [[ -d $dkms_tree/$1/original_module/$3/$4 ]] && echo -n " (original_module exists)"
     for ((count=0; count < ${#dest_module_name[@]}; count++)); do
-	tree_mod="$dkms_tree/$1/$2/$3/$4/module/${dest_module_name[$count]}$module_suffix"
-	if ! [[ -e $tree_mod ]]; then
-	    echo -n " (WARNING! Missing some built modules!)"
-	elif _is_module_installed "$@"; then
-	    real_dest="$(find_actual_dest_module_location "$1" $count "$3" "$4")"
-	    if ! diff -q "$tree_mod" "$install_tree/$3${real_dest}/${dest_module_name[$count]}$module_suffix" >/dev/null 2>&1; then
-		echo -n " (WARNING! Diff between built and installed module!)"
-	    fi
-	fi
+        tree_mod="$dkms_tree/$1/$2/$3/$4/module/${dest_module_name[$count]}$module_suffix"
+        if ! [[ -e $tree_mod ]]; then
+            echo -n " (WARNING! Missing some built modules!)"
+        elif _is_module_installed "$@"; then
+            real_dest="$(find_actual_dest_module_location "$1" $count "$3" "$4")"
+            if ! diff -q "$tree_mod" "$install_tree/$3${real_dest}/${dest_module_name[$count]}$module_suffix" >/dev/null 2>&1; then
+                echo -n " (WARNING! Diff between built and installed module!)"
+            fi
+        fi
     done
 )
 
@@ -1872,17 +1920,16 @@ module_status_built_extra() (
 module_status_built() {
     local ret=1 directory ka k a state oifs="$IFS" IFS=''
     for directory in "$dkms_tree/$1/$2/"${3:-[0-9].*}/${4:-*}; do
-	IFS="$oifs"
-	ka="${directory#$dkms_tree/$1/$2/}"
-	k="${ka%/*}"
-	a="${ka#*/}"
-	is_module_built "$1" "$2" "$k" "$a" || continue
-	ret=0
-	state="built"
-	_is_module_installed "$1" "$2" "$k" "$a" && \
-	    state="installed"
-	echo "$state $1/$2/$k/$a"
-	IFS=''
+        IFS="$oifs"
+        ka="${directory#$dkms_tree/$1/$2/}"
+        k="${ka%/*}"
+        a="${ka#*/}"
+        is_module_built "$1" "$2" "$k" "$a" || continue
+        ret=0
+        state="built"
+        _is_module_installed "$1" "$2" "$k" "$a" && state="installed"
+        echo "$state $1/$2/$k/$a"
+        IFS=''
     done
     IFS="$oifs"
     return $ret
@@ -1892,14 +1939,14 @@ module_status_built() {
 module_status() {
     local oifs="$IFS" IFS='' mv m v directory ret=1
     for directory in "$dkms_tree/"${1:-*}/${2:-*}; do
-	IFS="$oifs"
-	mv="${directory#$dkms_tree/}"
-	m="${mv%/*}"
-	v="${mv#*/}"
-	is_module_added "$m" "$v" || continue
-	ret=0
-	module_status_built "$m" "$v" "$3" "$4" || echo "added $m/$v"
-	IFS=''
+        IFS="$oifs"
+        mv="${directory#$dkms_tree/}"
+        m="${mv%/*}"
+        v="${mv#*/}"
+        is_module_added "$m" "$v" || continue
+        ret=0
+        module_status_built "$m" "$v" "$3" "$4" || echo "added $m/$v"
+        IFS=''
     done
     IFS="$oifs"
     return $ret
@@ -1911,13 +1958,17 @@ module_status() {
 do_status() {
     local status mvka m v k a
     while read status mvka; do
-	IFS=/ read m v k a <<< "$mvka"
-	case $status in
-	    added) echo "$m, $v: $status";;
-	    built|installed) echo -n "$m, $v, $k, $a: $status"
-		module_status_built_extra "$m" "$v" "$k" "$a"
-		echo;;
-	esac
+        IFS=/ read m v k a <<< "$mvka"
+        case $status in
+            added)
+                echo "$m, $v: $status"
+                ;;
+            built|installed)
+                echo -n "$m, $v, $k, $a: $status"
+                module_status_built_extra "$m" "$v" "$k" "$a"
+                echo
+                ;;
+        esac
     done < <(module_status "$@")
 }
 
@@ -1927,13 +1978,13 @@ show_status()
 {
     local j state_array
     if ((${#kernelver[@]} == 0)); then
-	do_status "$module" "$module_version" "$kernelver" "$arch"
-	do_status_weak "$module" "$module_version" "$kernelver" "$arch"
+        do_status "$module" "$module_version" "$kernelver" "$arch"
+        do_status_weak "$module" "$module_version" "$kernelver" "$arch"
     else
-	for ((j=0; j < ${#kernelver[@]}; j++)); do
-	    do_status "$module" "$module_version" "${kernelver[$j]}" "${arch[$j]}"
-	    do_status_weak "$module" "$module_version" "${kernelver[$j]}" "${arch[$j]}"
-	done
+    for ((j=0; j < ${#kernelver[@]}; j++)); do
+        do_status "$module" "$module_version" "${kernelver[$j]}" "${arch[$j]}"
+        do_status_weak "$module" "$module_version" "${kernelver[$j]}" "${arch[$j]}"
+    done
     fi
 }
 
@@ -1966,7 +2017,10 @@ delete_temporary_trees()
     temporary_trees_del_command=
 }
 
-in_temporary_trees() { [[ $temporary_trees_del_command ]] ;}
+in_temporary_trees()
+{
+    [[ $temporary_trees_del_command ]]
+}
 
 media_valid()
 {
@@ -1985,8 +2039,12 @@ make_driver_disk_floppy()
     rm -f "$image_name"
     invoke_command "dd if=/dev/zero of=$image_name bs=$(($size/20))k count=20" "making a blank floppy image" background
     case $fs in
-	vfat) invoke_command "mkdosfs $image_name" "mkdosfs" background;;
-	ext2) invoke_command "mke2fs -F $image_name" "mke2fs" background;;
+        vfat)
+            invoke_command "mkdosfs $image_name" "mkdosfs" background
+            ;;
+        ext2)
+            invoke_command "mke2fs -F $image_name" "mke2fs" background
+            ;;
     esac
 
     local mntdir=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
@@ -2004,8 +2062,12 @@ make_driver_disk_isotar()
     local source_dir="$3"
     local file
     case $type in
-	iso) invoke_command "mkisofs -v -r -J -pad -V $module -o $image_name ." "mkisofs" background;;
-	tar) invoke_command "tar cvf $image_name ." "tar" background;;
+        iso)
+            invoke_command "mkisofs -v -r -J -pad -V $module -o $image_name ." "mkisofs" background
+            ;;
+        tar)
+            invoke_command "tar cvf $image_name ." "tar" background
+            ;;
     esac
 }
 
@@ -2014,79 +2076,91 @@ make_driver_disk_media()
     echo "Copying files $2"
 
     case $media in
-	floppy*) make_driver_disk_floppy "$1" "$2";;
-	iso*) make_driver_disk_isotar "iso" "$1" "$2";;
-	tar*) make_driver_disk_isotar "tar" "$1" "$2";;
+        floppy*)
+            make_driver_disk_floppy "$1" "$2"
+            ;;
+        iso*)
+            make_driver_disk_isotar "iso" "$1" "$2"
+            ;;
+        tar*)
+            make_driver_disk_isotar "tar" "$1" "$2"
+            ;;
     esac
 }
 
 driver_disk_suffix()
 {
     case $media in
-	floppy*) echo "img";;
-	iso*) echo "iso";;
-	tar*) echo "tar";;
+    floppy*)
+        echo "img"
+        ;;
+    iso*)
+        echo "iso"
+        ;;
+    tar*)
+        echo "tar"
+        ;;
     esac
 }
 
 make_redhat_driver_disk()
 {
     local i count
-    # kludge to allow redhat1 driver disks with BOOT kernel modules (arch i386)
+    # Kludge to allow redhat1 driver disks with BOOT kernel modules (arch i386)
     if [[ $distro = redhat1 && $multi_arch = true ]]; then
-	local redhat1_okay="true"
-	local other_arch=""
-	for ((i=0; i < ${#kernelver[@]}; i++)); do
-	    if [[ ${arch[$i]} != i386 && $other_arch != ${arch[$i]} && $other_arch ]]; then
-		die 3 $"You have specified a Red Hat version 1 driver disk, but have also" \
-		    $"specified multiple architectures.  Version 1 does not support this." \
-		    $"Use 'redhat2' instead (only OSes >= RHEL3, FC1 support version 2)."
-	    elif [[ ${arch[$i]} != i386 && $other_arch != ${arch[$i]} && ! $other_arch ]]; then
-		other_arch="${arch[$i]}"
-	    fi
-	done
+        local redhat1_okay="true"
+        local other_arch=""
+        for ((i=0; i < ${#kernelver[@]}; i++)); do
+            if [[ ${arch[$i]} != i386 && $other_arch != ${arch[$i]} && $other_arch ]]; then
+                die 3 $"You have specified a Red Hat version 1 driver disk, but have also" \
+                    $"specified multiple architectures.  Version 1 does not support this." \
+                    $"Use 'redhat2' instead (only OSes >= RHEL3, FC1 support version 2)."
+            elif [[ ${arch[$i]} != i386 && $other_arch != ${arch[$i]} && ! $other_arch ]]; then
+                other_arch="${arch[$i]}"
+            fi
+        done
     fi
     if [ "$distro" == "redhat2" ]  && [ -z "$redhat1_okay" ]; then
-	echo $"Creating Red Hat v2 driver disk (arch support)."
-	echo $""
-	local rhdd_filename="rhdd"
+        echo $"Creating Red Hat v2 driver disk (arch support)."
+        echo $""
+        local rhdd_filename="rhdd"
     elif [ "$distro" == "redhat3" ] && [ -z "$redhat1_okay" ]; then
         echo $"Creating Red Hat v3 driver disk."
-	echo $""
-	make_redhat3_driver_disk
-	return
+        echo $""
+        make_redhat3_driver_disk
+        return
     else
-	echo $"Creating Red Hat v1 driver disk."
-	echo $""
-	local rhdd_filename="rhdd-6.1"
+        echo $"Creating Red Hat v1 driver disk."
+        echo $""
+        local rhdd_filename="rhdd-6.1"
     fi
 
     cpioarchive_dir_name=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
 
     for ((i=0; i < ${#kernelver[@]}; i++)); do
-	set_module_suffix "${kernelver[$i]}"
-
-	local dd_prefix="${kernelver[$i]}"
-	[[ $distro = redhat2 ]] && dd_prefix="${kernelver[$i]}/${arch[$i]}"
-	[[ $multi_arch = true && -z $redhat1_okay ]] && dd_prefix="${kernelver[$i]}/${arch[$i]}"
-	maybe_build_module "$module" "$module_version" "${kernelver[$i]}" "${arch[$i]}" || {
-	    rm -rf "$cpioarchive_dir_name"
-	    die 5 $"Cannot build $module/$module_version for redhat driver disk."
-	}
-	
-	# FIXME: add check for KMP binary RPMs to include in the driver disk
-	if [[ ! $kernel_version_list ]]; then
-	    kernel_version_list="kernel${kernelver[$i]}-${arch[$i]}"
-	else
-	    kernel_version_list="$kernel_version_list-kernel${kernelver[$i]}-${arch[$i]}"
-	fi
-	mkdir -p $cpioarchive_dir_name/$dd_prefix
-	for f in "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/"*"$module_suffix"; do
-	    [[ -f $f ]] || continue
-	    echo "Marking ${f#$dkms_tree/$module/$module_version/}..."
-	    cp "$f" "$cpioarchive_dir_name/$dd_prefix/"
-	    modules_cgz_list="$dd_prefix/${f##*/} ${modules_cgz_list}"
-	done
+        set_module_suffix "${kernelver[$i]}"
+
+        local dd_prefix="${kernelver[$i]}"
+        [[ $distro = redhat2 ]] && dd_prefix="${kernelver[$i]}/${arch[$i]}"
+        [[ $multi_arch = true && -z $redhat1_okay ]] && dd_prefix="${kernelver[$i]}/${arch[$i]}"
+        maybe_build_module "$module" "$module_version" "${kernelver[$i]}" "${arch[$i]}" || {
+            rm -rf "$cpioarchive_dir_name"
+            die 5 $"Cannot build $module/$module_version for redhat driver disk."
+        }
+
+        # FIXME: add check for KMP binary RPMs to include in the driver disk
+        if [[ ! $kernel_version_list ]]; then
+            kernel_version_list="kernel${kernelver[$i]}-${arch[$i]}"
+        else
+            kernel_version_list="$kernel_version_list-kernel${kernelver[$i]}-${arch[$i]}"
+        fi
+        mkdir -p $cpioarchive_dir_name/$dd_prefix
+        for f in "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/"*"$module_suffix"; do
+            [[ -f $f ]] || continue
+            echo "Marking ${f#$dkms_tree/$module/$module_version/}..."
+            cp "$f" "$cpioarchive_dir_name/$dd_prefix/"
+            modules_cgz_list="$dd_prefix/${f##*/} ${modules_cgz_list}"
+        done
 
     done
 
@@ -2101,18 +2175,18 @@ make_redhat_driver_disk()
 
     local files_into_driverdisk="modules.cgz $rhdd_filename modules.alias"
     for file in $files_for_driverdisk; do
-	if [[ -e $dkms_tree/$module/$module_version/source/redhat_driver_disk/$file ]]; then
-	    files_into_driverdisk="$file $files_into_driverdisk"
-	    cp -f "$dkms_tree/$module/$module_version/source/redhat_driver_disk/$file" "$driver_disk_dir/" 2>/dev/null
-	else
-	    warn $"File: $file not found in $dkms_tree/$module/$module_version/source/redhat_driver_disk/"
-	fi
+        if [[ -e $dkms_tree/$module/$module_version/source/redhat_driver_disk/$file ]]; then
+            files_into_driverdisk="$file $files_into_driverdisk"
+            cp -f "$dkms_tree/$module/$module_version/source/redhat_driver_disk/$file" "$driver_disk_dir/" 2>/dev/null
+        else
+            warn $"File: $file not found in $dkms_tree/$module/$module_version/source/redhat_driver_disk/"
+        fi
     done
     echo "$module-$module_version driver disk" > "$driver_disk_dir/$rhdd_filename"
 
     # Make sure the kernel_version_list is not too long
     if (( $(echo $kernel_version_list | wc -m | awk {'print $1'}) > 200 )); then
-	kernel_version_list="manykernels"
+        kernel_version_list="manykernels"
     fi
 
     local suffix="$(driver_disk_suffix)"
@@ -2124,17 +2198,17 @@ make_redhat_driver_disk()
     invoke_command "echo '$modules_cgz_list' | cpio -oH crc 2>/dev/null | gzip -9 > ./modules.cgz" "compressing modules.cgz" background
     cp -f ./modules.cgz "$driver_disk_dir/"
 
-    # generate modules.alias file
+    # Generate modules.alias file
     # On 2.4 kernels and kernels with no aliases. this won't yield anything.
     touch ./modules.alias
     for f in ${modules_cgz_list}; do
-	module_wo_suffix=$(basename ${f} ${module_suffix})
-	tmp_alias="./modules.alias.${module_wo_suffix}"
-	f="./${f}"
-	depmod -n ${f} 2>/dev/null | grep ^alias > ${tmp_alias}
-	if [[ -s ${tmp_alias} ]]; then
-	    cat "${tmp_alias}" >> ./modules.alias
-	fi
+        module_wo_suffix=$(basename ${f} ${module_suffix})
+        tmp_alias="./modules.alias.${module_wo_suffix}"
+        f="./${f}"
+        depmod -n ${f} 2>/dev/null | grep ^alias > ${tmp_alias}
+        if [[ -s ${tmp_alias} ]]; then
+            cat "${tmp_alias}" >> ./modules.alias
+        fi
     done
     [[ -e ./modules.alias ]] && cp -f ./modules.alias "$driver_disk_dir/"
     # FIXME: add rpms/ directory, copy in KMP RPMs, run createrepo --pretty
@@ -2160,15 +2234,15 @@ make_driver_disk()
 {
     # Check that the right arguments were passed
     if ! [[ $module && $module_version && $distro && $kernelver ]]; then
-	die 1 $"Invalid number of parameters passed." \
-	$"Usage: mkdriverdisk <module>/<module-version> -d <distro> -k <kernelver> [--media floppy|iso|tar]"
+        die 1 $"Invalid number of parameters passed." \
+        $"Usage: mkdriverdisk <module>/<module-version> -d <distro> -k <kernelver> [--media floppy|iso|tar]"
     fi
 
-    # default to floppy media
+    # Default to floppy media
     [[ $media ]] || media="floppy"
     if ! media_valid; then
-	die 1 $"Media $media is invalid." \
-	    $"Usage: mkdriverdisk <module>/<module-version> -d <distro> -k <kernelver> [--media floppy|iso|tar]"
+        die 1 $"Media $media is invalid." \
+            $"Usage: mkdriverdisk <module>/<module-version> -d <distro> -k <kernelver> [--media floppy|iso|tar]"
     fi
 
     # Check that source symlink works
@@ -2176,19 +2250,28 @@ make_driver_disk()
 
     # Confirm that distro is supported
     case $distro in
-	redhat | redhat[123] | suse | UnitedLinux | ubuntu) ;;
-	*) die 3 $"Invalid distro argument. Currently, the distros" \
-		$"supported are: redhat, redhat1, redhat2, redhat3, suse, UnitedLinux" \
-		$"               ubuntu";;
+        redhat | redhat[123] | suse | UnitedLinux | ubuntu)
+            ;;
+        *)
+            die 3 $"Invalid distro argument. Currently, the distros" \
+                $"supported are: redhat, redhat1, redhat2, redhat3, suse, UnitedLinux" \
+                $"               ubuntu"
+            ;;
     esac
 
     # Read the conf file
     read_conf_or_die "$kernelver" "$arch"
 
     case $distro in
-	redhat*) make_redhat_driver_disk;;
-	ubuntu) make_ubuntu_driver_disk;;
-	*) make_suse_driver_disk;;
+        redhat*)
+            make_redhat_driver_disk
+            ;;
+        ubuntu)
+            make_ubuntu_driver_disk
+            ;;
+        *)
+            make_suse_driver_disk
+            ;;
     esac
 }
 
@@ -2197,34 +2280,34 @@ find_external_dependencies()
     local mod count i
     local -a deps
 
-    # find all module dependencies
+    # Find all module dependencies
     for ((count=0; count < ${#dest_module_name[@]}; count++)); do
-	for ((i=0; i < ${#kernelver[@]}; i++)); do
-	    set_module_suffix "${kernelver[$i]}"
-	    mod="$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/${dest_module_name[$count]}$module_suffix"
-	    deps=(${deps[@]} $(modinfo "$mod" | sed -n 's/,/ /g; s/^depends: *//p'))
-	done
+        for ((i=0; i < ${#kernelver[@]}; i++)); do
+            set_module_suffix "${kernelver[$i]}"
+            mod="$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/${dest_module_name[$count]}$module_suffix"
+            deps=(${deps[@]} $(modinfo "$mod" | sed -n 's/,/ /g; s/^depends: *//p'))
+        done
     done
 
-    # prune internally satisfied dependencies
+    # Prune internally satisfied dependencies
 
     for ((i=0; i < ${#deps[@]}; i++)); do
-	for mod in ${dest_module_name[@]}; do
-	    [[ ${deps[i]} = $mod ]] && deps[i]=
-	done
+        for mod in ${dest_module_name[@]}; do
+            [[ ${deps[i]} = $mod ]] && deps[i]=
+        done
     done
 
     for dep in "${deps[@]}"; do
-	echo $dep
+        echo $dep
     done | sort -u
 }
 
 make_suse_driver_disk()
 {
     [[ $release ]] || die 3 \
-	$"Invalid number of parameters passed for suse/UnitedLinux driver disk." \
-	$"Usage: mkdriverdisk <module>/<module-version> -d <distro> -k <kernelver>" \
-	$"                    -r <release-number>"
+        $"Invalid number of parameters passed for suse/UnitedLinux driver disk." \
+        $"Usage: mkdriverdisk <module>/<module-version> -d <distro> -k <kernelver>" \
+        $"                    -r <release-number>"
 
     local driver_disk_dir=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
     local suffix="$(driver_disk_suffix)"
@@ -2242,95 +2325,96 @@ make_suse_driver_disk()
     
     local count
     for ((count=0; count < ${#dest_module_name[@]}; count++)); do
-	local i
-	local topdir=$(printf "%02d" $(($count+1+offset)))
-	for ((i=0; i < ${#kernelver[@]}; i++)); do
-	    set_module_suffix "${kernelver[$i]}"
-
-	    if ! [[ -e $dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/${dest_module_name[$count]}$module_suffix ]]; then
-		rm -rf $temp_dir_name
-		die 5 \
-		    $"Cannot find module ${dest_module_name[$count]}$module_suffix for kernel ${kernelver[$i]} (${arch[$i]})." \
-		    $"Module/version must be in built state before making a driver disk."
-	    fi
-	    # FIXME: add check for KMP binary RPMs to include in the driver disk
-	    suse_arch=${arch[$i]}
-	    case $suse_arch in
-		i?86) suse_arch=i386;;
-	    esac
-
-	    echo "Marking ${kernelver[$i]}/${arch[$i]}/modules/${dest_module_name[$count]}$module_suffix..."
-	    mkdir -p "$driver_disk_dir/$topdir/$suse_arch-$release/install/lib/modules/${kernelver[$i]}${dest_module_location[$count]}"
-	    cp "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/${dest_module_name[$count]}$module_suffix" "$driver_disk_dir/$topdir/$suse_arch-$release/install/lib/modules/${kernelver[$i]}${dest_module_location[$count]}/"
-
-	    case ${kernelver[$i]} in
-		*-default)
-		    mkdir -p "$driver_disk_dir/$topdir/$suse_arch-$release/modules/"
-		    cp "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/${dest_module_name[$count]}$module_suffix" "$driver_disk_dir/$topdir/$suse_arch-$release/modules/"
-		    ;;
-	    esac
-
-	    # create directory for dependency information
-	    [[ ${deps[@]} ]] && mkdir -p "$driver_disk_dir/01/linux/$distro/$suse_arch-$release/modules"
-
-	done
-
-	# ---
-	for arch_release in $(find $driver_disk_dir/$topdir -maxdepth 1 -mindepth 1 -type d | sed "s#$driver_disk_dir\/$topdir\/##"); do
-	    cd "$driver_disk_dir/$topdir/$arch_release/install/"
-	    invoke_command "tar cvzf update.tar.gz lib/" "making update.tar.gz for $arch_release" background
-	    cd - >/dev/null
-
-	    mkdir -p "$driver_disk_dir/$topdir/linux/$distro/$arch_release/install"
-	    mkdir -p "$driver_disk_dir/$topdir/linux/$distro/$arch_release/modules"
-
-	    echo $"  copying update.tar.gz for $arch_release to disk image..."
-	    cp -f "$driver_disk_dir/$topdir/$arch_release/install/update.tar.gz" "$driver_disk_dir/$topdir/linux/$distro/$arch_release/install/"
-
-	    postkernels=
-	    archtest=${arch_release/-*}
-	    for ((i=0; i<${#kernelver[@]}; i++)); do
-		[[ ${arch[$i]} = ${archtest} ]] && \
-		    postkernels="${postkernels} ${kernelver[$i]}"
-	    done
-
-	    if [[ ${postkernels} ]]; then
-		dstfile="$driver_disk_dir/$topdir/linux/$distro/$arch_release/install/update.post"
-		echo $"  creating update.post for $arch_release..."
-		(cat << EOF
+    local i
+    local topdir=$(printf "%02d" $(($count+1+offset)))
+    for ((i=0; i < ${#kernelver[@]}; i++)); do
+        set_module_suffix "${kernelver[$i]}"
+
+        if ! [[ -e $dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/${dest_module_name[$count]}$module_suffix ]]; then
+            rm -rf $temp_dir_name
+            die 5 \
+                $"Cannot find module ${dest_module_name[$count]}$module_suffix for kernel ${kernelver[$i]} (${arch[$i]})." \
+                $"Module/version must be in built state before making a driver disk."
+        fi
+        # FIXME: add check for KMP binary RPMs to include in the driver disk
+        suse_arch=${arch[$i]}
+        case $suse_arch in
+            i?86)
+                suse_arch=i386
+                ;;
+        esac
+
+        echo "Marking ${kernelver[$i]}/${arch[$i]}/modules/${dest_module_name[$count]}$module_suffix..."
+        mkdir -p "$driver_disk_dir/$topdir/$suse_arch-$release/install/lib/modules/${kernelver[$i]}${dest_module_location[$count]}"
+        cp "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/${dest_module_name[$count]}$module_suffix" "$driver_disk_dir/$topdir/$suse_arch-$release/install/lib/modules/${kernelver[$i]}${dest_module_location[$count]}/"
+
+        case ${kernelver[$i]} in
+        *-default)
+            mkdir -p "$driver_disk_dir/$topdir/$suse_arch-$release/modules/"
+            cp "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/${dest_module_name[$count]}$module_suffix" "$driver_disk_dir/$topdir/$suse_arch-$release/modules/"
+            ;;
+        esac
+
+        # Create directory for dependency information
+        [[ ${deps[@]} ]] && mkdir -p "$driver_disk_dir/01/linux/$distro/$suse_arch-$release/modules"
+
+    done
+
+    # ---
+    for arch_release in $(find $driver_disk_dir/$topdir -maxdepth 1 -mindepth 1 -type d | sed "s#$driver_disk_dir\/$topdir\/##"); do
+        cd "$driver_disk_dir/$topdir/$arch_release/install/"
+        invoke_command "tar cvzf update.tar.gz lib/" "making update.tar.gz for $arch_release" background
+        cd - >/dev/null
+
+        mkdir -p "$driver_disk_dir/$topdir/linux/$distro/$arch_release/install"
+        mkdir -p "$driver_disk_dir/$topdir/linux/$distro/$arch_release/modules"
+
+        echo $"  copying update.tar.gz for $arch_release to disk image..."
+        cp -f "$driver_disk_dir/$topdir/$arch_release/install/update.tar.gz" "$driver_disk_dir/$topdir/linux/$distro/$arch_release/install/"
+
+        postkernels=
+        archtest=${arch_release/-*}
+        for ((i=0; i<${#kernelver[@]}; i++)); do
+            [[ ${arch[$i]} = ${archtest} ]] && postkernels="${postkernels} ${kernelver[$i]}"
+        done
+
+        if [[ ${postkernels} ]]; then
+            dstfile="$driver_disk_dir/$topdir/linux/$distro/$arch_release/install/update.post"
+            echo $"  creating update.post for $arch_release..."
+            (cat << EOF
 #!/bin/sh
 
 kernlist="${postkernels}"
 
 for kernel in \${kernlist}; do
     if [ -e /boot/System.map-\${kernel} ]; then
-	depmod -a -F /boot/System.map-\${kernel} \${kernel}
+    depmod -a -F /boot/System.map-\${kernel} \${kernel}
     fi
 done
 
 EOF
-		) > ${dstfile}
-		chmod a+x ${dstfile}
-	    fi
-
-	    if [[ -d $driver_disk_dir/$topdir/$arch_release/modules/ ]]; then
-		echo $"  copying kernel modules for installation kernel to disk image..."
-		cp -f $driver_disk_dir/$topdir/$arch_release/modules/* $driver_disk_dir/$topdir/linux/$distro/$arch_release/modules/ 2>/dev/null
-	    else
-		warn $"No kernel modules found for -default kernel."
-	    fi
-
-	    rm -fr "$driver_disk_dir/$topdir/$arch_release"
-	done
+            ) > ${dstfile}
+            chmod a+x ${dstfile}
+            fi
+
+            if [[ -d $driver_disk_dir/$topdir/$arch_release/modules/ ]]; then
+                echo $"  copying kernel modules for installation kernel to disk image..."
+                cp -f $driver_disk_dir/$topdir/$arch_release/modules/* $driver_disk_dir/$topdir/linux/$distro/$arch_release/modules/ 2>/dev/null
+            else
+                warn $"No kernel modules found for -default kernel."
+            fi
+
+            rm -fr "$driver_disk_dir/$topdir/$arch_release"
+        done
     done
 
     local dir
     if [[ ${deps[@]} ]]; then
-	for dir in "$driver_disk_dir/01/linux/$distro/"*"/modules"; do
-	    for dep in "${deps[@]}"; do
-		echo $dep >> "$dir/module.order"
-	    done
-	done
+        for dir in "$driver_disk_dir/01/linux/$distro/"*"/modules"; do
+            for dep in "${deps[@]}"; do
+                echo $dep >> "$dir/module.order"
+            done
+        done
     fi
 
     # FIXME: add suse-equivalent rpms/ directory, copy in KMP RPMs, run createrepo --pretty
@@ -2356,33 +2440,33 @@ make_ubuntu_driver_disk()
 
     local tempdir=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
 
-   # Check that the dh_make command is present
-   if ! which dpkg-deb >/dev/null 2>&1 ; then
-	die 1 $"dpkg-deb not present." \
-	    $"Install the dpkg-dev package."
-   fi
-
-   local i
-   for ((i=0; i < ${#kernelver[@]}; i++)); do
-      set_module_suffix "${kernelver[$i]}"
-      # Driver disks only recognize i386 as package arch
-      local karch=${arch[$i]/i?86/i386}
-      local kvers=${kernelver[$i]/-/_}; kvers=${kvers%%_*}
-       # ubuntu-drivers/<kver>/*_<debarch>.deb
-      local dd_prefix="ubuntu-drivers/$kvers"
-      local dd_suffix="_${karch}.deb"
-      maybe_build_module "$module" "$module_version" "${kernelver[$i]}" "${arch[$i]}" || {
-	  rm -rf "$tempdir"
-	  die 5 $"Unable to build $module/$module_version for Ubuntu driver disk."
-      }
-      mkdir -p "$tempdir/$dd_prefix"
-      local deb_dir="$tempdir/$dd_prefix/debian"
-      local deb_lib_dir="$deb_dir/lib/modules/${kernelver[$i]}/updates/dkms"
-      mkdir -p "$deb_lib_dir"
-      cp "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/"*"$module_suffix" "$deb_lib_dir"
-      pushd "$deb_dir" > /dev/null 2>&1
-      mkdir DEBIAN
-      cat > DEBIAN/control <<EOF
+    # Check that the dh_make command is present
+    if ! which dpkg-deb >/dev/null 2>&1 ; then
+        die 1 $"dpkg-deb not present." \
+            $"Install the dpkg-dev package."
+    fi
+
+    local i
+    for ((i=0; i < ${#kernelver[@]}; i++)); do
+        set_module_suffix "${kernelver[$i]}"
+        # Driver disks only recognize i386 as package arch
+        local karch=${arch[$i]/i?86/i386}
+        local kvers=${kernelver[$i]/-/_}; kvers=${kvers%%_*}
+        # ubuntu-drivers/<kver>/*_<debarch>.deb
+        local dd_prefix="ubuntu-drivers/$kvers"
+        local dd_suffix="_${karch}.deb"
+        maybe_build_module "$module" "$module_version" "${kernelver[$i]}" "${arch[$i]}" || {
+            rm -rf "$tempdir"
+            die 5 $"Unable to build $module/$module_version for Ubuntu driver disk."
+        }
+        mkdir -p "$tempdir/$dd_prefix"
+        local deb_dir="$tempdir/$dd_prefix/debian"
+        local deb_lib_dir="$deb_dir/lib/modules/${kernelver[$i]}/updates/dkms"
+        mkdir -p "$deb_lib_dir"
+        cp "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}/module/"*"$module_suffix" "$deb_lib_dir"
+        pushd "$deb_dir" > /dev/null 2>&1
+        mkdir DEBIAN
+        cat > DEBIAN/control <<EOF
 Package: ${module}-modules-${kernelver[$i]}
 Version: ${module_version}-1
 Section: misc
@@ -2434,10 +2518,10 @@ make_tarball()
 
     # Check for dkms_dbversion
     if ! [[ -e $dkms_tree/dkms_dbversion ]]; then
-	echo $"" >&2
-	echo $"Could not find the file $dkms_tree/dkms_dbversion." >&2
-	echo $"Creating w/ default contents." >&2
-	echo "2.0.0" > $dkms_tree/dkms_dbversion
+        echo $"" >&2
+        echo $"Could not find the file $dkms_tree/dkms_dbversion." >&2
+        echo $"Creating w/ default contents." >&2
+        echo "2.0.0" > $dkms_tree/dkms_dbversion
     fi
 
     # Read the conf file
@@ -2447,26 +2531,26 @@ make_tarball()
     mkdir -p $temp_dir_name/dkms_main_tree
 
     if [[ $source_only ]]; then
-	kernel_version_list="source-only"
+    kernel_version_list="source-only"
     else
-	local i
-	for ((i=0; i<${#kernelver[@]}; i++)); do
-	    if ! [[ -d $dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]} ]]; then
-		rm -rf "$temp_dir_name" 2>/dev/null
-		die 6  $"No modules built for ${kernelver[$i]} (${arch[$i]})." \
-		    $"Modules must already be in the built state before using mktarball."
-	    fi
-
-	    set_module_suffix "${kernelver[$i]}"
-
-	    echo "Marking modules for ${kernelver[$i]} (${arch[$i]}) for archiving..."
-	    if [[ ! $kernel_version_list ]]; then
-		kernel_version_list="kernel${kernelver[$i]}-${arch[$i]}"
-	    else
-		kernel_version_list="${kernel_version_list}-kernel${kernelver[$i]}-${arch[$i]}"
-	    fi
-	    mkdir -p "$temp_dir_name/dkms_main_tree/${kernelver[$i]}/${arch[$i]}"
-	    cp -rf "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}" "$temp_dir_name/dkms_main_tree/${kernelver[$i]}"
+    local i
+    for ((i=0; i<${#kernelver[@]}; i++)); do
+        if ! [[ -d $dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]} ]]; then
+            rm -rf "$temp_dir_name" 2>/dev/null
+            die 6  $"No modules built for ${kernelver[$i]} (${arch[$i]})." \
+                $"Modules must already be in the built state before using mktarball."
+        fi
+
+        set_module_suffix "${kernelver[$i]}"
+
+        echo "Marking modules for ${kernelver[$i]} (${arch[$i]}) for archiving..."
+        if [[ ! $kernel_version_list ]]; then
+            kernel_version_list="kernel${kernelver[$i]}-${arch[$i]}"
+        else
+            kernel_version_list="${kernel_version_list}-kernel${kernelver[$i]}-${arch[$i]}"
+        fi
+        mkdir -p "$temp_dir_name/dkms_main_tree/${kernelver[$i]}/${arch[$i]}"
+        cp -rf "$dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]}" "$temp_dir_name/dkms_main_tree/${kernelver[$i]}"
     done
     fi
 
@@ -2475,22 +2559,22 @@ make_tarball()
 
     # Copy the source_tree or make special binaries-only structure
     if [[ $binaries_only ]]; then
-	echo $""
-	echo $"Creating tarball structure to specifically accomodate binaries."
-	mkdir $temp_dir_name/dkms_binaries_only
-	echo "$module" > $temp_dir_name/dkms_binaries_only/PACKAGE_NAME
-	echo "$module_version" > $temp_dir_name/dkms_binaries_only/PACKAGE_VERSION
-	[[ ! $conf ]] && conf="$dkms_tree/$module/$module_version/source/dkms.conf"
-	cp -f $conf $temp_dir_name/dkms_binaries_only/ 2>/dev/null
+        echo $""
+        echo $"Creating tarball structure to specifically accomodate binaries."
+        mkdir $temp_dir_name/dkms_binaries_only
+        echo "$module" > $temp_dir_name/dkms_binaries_only/PACKAGE_NAME
+        echo "$module_version" > $temp_dir_name/dkms_binaries_only/PACKAGE_VERSION
+        [[ ! $conf ]] && conf="$dkms_tree/$module/$module_version/source/dkms.conf"
+        cp -f $conf $temp_dir_name/dkms_binaries_only/ 2>/dev/null
     else
-	echo $""
-	echo $"Marking $dkms_tree/$module/$module_version/source for archiving..."
-	mkdir -p $temp_dir_name/dkms_source_tree
-	cp -rf $dkms_tree/$module/$module_version/source/* $temp_dir_name/dkms_source_tree
+        echo $""
+        echo $"Marking $dkms_tree/$module/$module_version/source for archiving..."
+        mkdir -p $temp_dir_name/dkms_source_tree
+        cp -rf $dkms_tree/$module/$module_version/source/* $temp_dir_name/dkms_source_tree
     fi
 
     if (( $(echo $kernel_version_list | wc -m | awk {'print $1'}) > 200 )); then
-	kernel_version_list="manykernels"
+        kernel_version_list="manykernels"
     fi
 
     local tarball_name="$module-$module_version-$kernel_version_list.dkms.tar.gz"
@@ -2498,16 +2582,16 @@ make_tarball()
 
     # Die if we will not be able to create the tarball due to permissions.
     if [[ $archive_location ]]; then
-	tarball_name="${archive_location##*/}"
+        tarball_name="${archive_location##*/}"
         if [[ ${archive_location%/*} != $archive_location && \
             -d ${archive_location%/*} && -w ${archive_location%/*} ]]; then
             tarball_dest="${archive_location%/*}"
         elif [[ ${archive_location%/*} != $archive_location ]] && ! mkdir -p $tarball_dest; then
-	    die 9 $"Will not be able to create $archive_location due to a permissions problem."
-	fi
+            die 9 $"Will not be able to create $archive_location due to a permissions problem."
+        fi
     fi
     if [ ! -d $tarball_dest ]; then
-	mkdir -p "$dkms_tree/$module/$module_version/tarball/"
+        mkdir -p "$dkms_tree/$module/$module_version/tarball/"
     fi
 
     echo $""
@@ -2519,19 +2603,25 @@ make_tarball()
     # Make the tarball
     cd $temp_dir_name
     if tar -cf $temp_dir_name/$tarball_name ./* 2>/dev/null; then
-	cd - >/dev/null
-	echo $""
-	mv -f "$temp_dir_name/$tarball_name" "$tarball_dest/$tarball_name"
-	rm -rf $temp_dir_name
+        cd - >/dev/null
+        echo $""
+        mv -f "$temp_dir_name/$tarball_name" "$tarball_dest/$tarball_name"
+        rm -rf $temp_dir_name
     else
-	cd - >/dev/null
-	rm -rf $temp_dir_name
-	die 6 $"Failed to make tarball."
+        cd - >/dev/null
+        rm -rf $temp_dir_name
+        die 6 $"Failed to make tarball."
     fi
     case $tarball_ext in
-	gz) gzip --force -9 "$tarball_dest/$tarball_name";;
-	bz2) bzip2 --force -9 "$tarball_dest/$tarball_name";;
-	xz) xz --force -9 "$tarball_dest/$tarball_name";;
+        gz)
+            gzip --force -9 "$tarball_dest/$tarball_name"
+            ;;
+        bz2)
+            bzip2 --force -9 "$tarball_dest/$tarball_name"
+            ;;
+        xz)
+            xz --force -9 "$tarball_dest/$tarball_name"
+            ;;
     esac
     echo $""
     echo $"DKMS: mktarball completed."
@@ -2551,7 +2641,7 @@ load_tarball()
 {
     # Error out if $archive_location does not exist
     if [[ ! -e $archive_location ]]; then
-	die 2 $"$archive_location does not exist."
+        die 2 $"$archive_location does not exist."
     fi
 
     # If it is an .rpm file. install it with rpm, run an autoinstall, and then exit.
@@ -2569,13 +2659,19 @@ load_tarball()
     # Note that this does not depend on the extensions being correct.
     local tar_options=""
     for xpand in gzip bzip xz; do
-	$xpand -t $archive_location 2>/dev/null || continue
-	case $xpand in
-	    gzip) tar_options=z;;
-	    bzip2) tar_options=j;;
-	    xz) tar_options=J;;
-	esac
-	break
+        $xpand -t $archive_location 2>/dev/null || continue
+        case $xpand in
+            gzip)
+                tar_options=z
+                ;;
+            bzip2)
+                tar_options=j
+                ;;
+            xz)
+                tar_options=J
+                ;;
+        esac
+        break
     done
 
     # Untar it into $tmp_location
@@ -2584,16 +2680,16 @@ load_tarball()
     tar -${tar_options}xf $archive_location -C $temp_dir_name
 
     if [[ ! $temp_dir_name/dkms_main_tree ]]; then
-	# Tarball was not generated from mktarball.
-	# Just find the dkms.conf file and load the source.
-	conf=$(find $temp_dir_name/ -name dkms.conf 2>/dev/null | head -n 1)
-	if [[ ! $conf ]]; then
-	    rm -rf $temp_dir_name
-	    die 3 $"Tarball does not appear to be a correctly formed" \
-		$"DKMS archive. No dkms.conf found within it."
-	fi
-	add_source_tree "${conf%dkms.conf}"
-	return
+    # Tarball was not generated from mktarball.
+    # Just find the dkms.conf file and load the source.
+    conf=$(find $temp_dir_name/ -name dkms.conf 2>/dev/null | head -n 1)
+    if [[ ! $conf ]]; then
+        rm -rf $temp_dir_name
+        die 3 $"Tarball does not appear to be a correctly formed" \
+            $"DKMS archive. No dkms.conf found within it."
+    fi
+    add_source_tree "${conf%dkms.conf}"
+    return
     fi
 
     # Check that dkms_dbversion is not a future version
@@ -2602,76 +2698,78 @@ load_tarball()
     # the structure of the tarball.
     db_from_tarball=$(cat $temp_dir_name/dkms_main_tree/dkms_dbversion 2>/dev/null)
     db_from_dkms=$(cat $dkms_tree/dkms_dbversion 2>/dev/null)
-    if [[ $db_from_tarball && $db_from_dkms && \
-	$(VER "$db_from_tarball") > $(VER "$db_from_dkms") ]]; then
-	die 9 \
-	    $"The tarball you are trying to load indicates it is database version" \
-	    $"$db_from_tarball.  This version of DKMS only supports $db_from_dkms or lower."
+    if [[ $db_from_tarball && $db_from_dkms && $(VER "$db_from_tarball") > $(VER "$db_from_dkms") ]]; then
+        die 9 \
+            $"The tarball you are trying to load indicates it is database version" \
+            $"$db_from_tarball.  This version of DKMS only supports $db_from_dkms or lower."
     fi
 
     # Make sure its a sane tarball. Sane ones will have one of the two
     # directories we test for.
     for loc in dkms_source_tree dkms_binaries_only ''; do
-	if [[ ! $loc ]]; then
-	    die 7 $"No valid dkms.conf in dkms_source_tree or dkms_binaries_only." \
-		$"$archive_location is not a valid DKMS tarball."
-	fi
-	local conf="$temp_dir_name/$loc/dkms.conf"
-	[[ -f $conf ]] || continue
-	if ! get_pkginfo_from_conf "$conf"; then
-	    echo >&2
-	    echo $"Malformed dkms.conf, refusing to load." >&2
-	    continue
-	fi
-	if is_module_added "$PACKAGE_NAME" "$PACKAGE_VERSION" && \
-	    [[ ! $force ]]; then
-	    die 8  $"$PACKAGE_NAME-$PACKAGE_VERSION is already added!" \
-		$"Aborting."
-	fi
-	module="$PACKAGE_NAME"; module_version="$PACKAGE_VERSION"
-	echo $""
-	echo $"Loading tarball for $module-$module_version"
-	case $loc in
-	    dkms_source_tree)
-		add_source_tree "$temp_dir_name/dkms_source_tree";;
-	    dkms_binaries_only)
-		#if there is a source tree on the system already, don't build a binaries stub
-		if [[ ! -d $source_tree/$module-$module_version ]]; then
-			echo $"Creating $dkms_tree/$module/$module_version/source"
-			mkdir -p "$dkms_tree/$module/$module_version/source"
-			echo $"Copying dkms.conf to $dkms_tree/$module/$module_version/source..."
-			cp -rf "$temp_dir_name/dkms_binaries_only/dkms.conf" "$dkms_tree/$module/$module_version/source"
-		fi;;
-	    *)  die 8 $"$FUNCNAME:$LINENO: Cannot happen." \
-		$"Report this error to dkms-devel@dell.com";;
-	esac
-	break
+    if [[ ! $loc ]]; then
+        die 7 $"No valid dkms.conf in dkms_source_tree or dkms_binaries_only." \
+            $"$archive_location is not a valid DKMS tarball."
+    fi
+    local conf="$temp_dir_name/$loc/dkms.conf"
+    [[ -f $conf ]] || continue
+    if ! get_pkginfo_from_conf "$conf"; then
+        echo >&2
+        echo $"Malformed dkms.conf, refusing to load." >&2
+        continue
+    fi
+    if is_module_added "$PACKAGE_NAME" "$PACKAGE_VERSION" && \
+        [[ ! $force ]]; then
+        die 8  $"$PACKAGE_NAME-$PACKAGE_VERSION is already added!" \
+        $"Aborting."
+    fi
+    module="$PACKAGE_NAME"; module_version="$PACKAGE_VERSION"
+    echo $""
+    echo $"Loading tarball for $module-$module_version"
+    case $loc in
+        dkms_source_tree)
+            add_source_tree "$temp_dir_name/dkms_source_tree"
+            ;;
+        dkms_binaries_only)
+            #if there is a source tree on the system already, don't build a binaries stub
+            if [[ ! -d $source_tree/$module-$module_version ]]; then
+                echo $"Creating $dkms_tree/$module/$module_version/source"
+                mkdir -p "$dkms_tree/$module/$module_version/source"
+                echo $"Copying dkms.conf to $dkms_tree/$module/$module_version/source..."
+                cp -rf "$temp_dir_name/dkms_binaries_only/dkms.conf" "$dkms_tree/$module/$module_version/source"
+            fi
+            ;;
+        *)
+            die 8 $"$FUNCNAME:$LINENO: Cannot happen." \
+                $"Report this error to dkms-devel@dell.com";;
+    esac
+    break
     done
 
-    # at this point, the source has been copied to the appropriate location
+    # At this point, the source has been copied to the appropriate location
     # and registered with dkms, or a binary-only config has been noted.
     # Now, add any included precompiled modules.
 
     # Is tarball from before DKMS 2.0 (prior to arch support)
     if [[ ! -e $temp_dir_name/dkms_main_tree/dkms_dbversion ]]; then
-	[[ $loc = dkms_binaries_only ]] && rm -rf "$dkms_tree/$module/$module_version/source"
-	die 10 $" This tarball was created with dkms < 2.0 and contains" \
-	    $"no arch info. DKMS is refusing to install precompiled modules."
+        [[ $loc = dkms_binaries_only ]] && rm -rf "$dkms_tree/$module/$module_version/source"
+        die 10 $" This tarball was created with dkms < 2.0 and contains" \
+            $"no arch info. DKMS is refusing to install precompiled modules."
     fi
 
     # Load precompiled modules.
     for directory in "$temp_dir_name/dkms_main_tree"/*/*; do
-	[[ -d $directory ]] || continue
-	kernel_arch_to_load=${directory/*dkms_main_tree\/}
-	dkms_dir_location="$dkms_tree/$module/$module_version/$kernel_arch_to_load"
-	if [[ -d $dkms_dir_location && ! $force ]]; then
-	    warn $"$dkms_dir_location already exists.  Skipping..."
-	else
-	    echo $"Loading $dkms_dir_location..."
-	    rm -rf $dkms_dir_location
-	    mkdir -p $dkms_dir_location
-	    cp -rf $directory/* $dkms_dir_location/
-	fi
+        [[ -d $directory ]] || continue
+        kernel_arch_to_load=${directory/*dkms_main_tree\/}
+        dkms_dir_location="$dkms_tree/$module/$module_version/$kernel_arch_to_load"
+        if [[ -d $dkms_dir_location && ! $force ]]; then
+            warn $"$dkms_dir_location already exists.  Skipping..."
+        else
+            echo $"Loading $dkms_dir_location..."
+            rm -rf $dkms_dir_location
+            mkdir -p $dkms_dir_location
+            cp -rf $directory/* $dkms_dir_location/
+        fi
     done
 
     echo $""
@@ -2685,14 +2783,14 @@ run_match()
 
     # Error if $template_kernel is unset
     if [[ ! $template_kernel ]]; then
-	die 1 $"Invalid number of parameters passed." \
-	    $"Usage: match --templatekernel=<kernel-version> -k <kernel-version>" \
-	    $"   or: match --templatekernel=<kernel-version> -k <kernel-version> <module>"
+        die 1 $"Invalid number of parameters passed." \
+            $"Usage: match --templatekernel=<kernel-version> -k <kernel-version>" \
+            $"   or: match --templatekernel=<kernel-version> -k <kernel-version> <module>"
     fi
 
     # Error out if $template_kernel = $kernel_version
     if [[ $template_kernel = $kernelver ]]; then
-	die 2 $"The templatekernel and the specified kernel version are the same."
+        die 2 $"The templatekernel and the specified kernel version are the same."
     fi
 
     # Read in the status of template_kernel
@@ -2700,11 +2798,11 @@ run_match()
 
     # If $module is set, grep the status only for that module
     if [[ $module ]]; then
-	# Make sure that its installed in the first place
-	if ! [[ -d $dkms_tree/$module/ ]]; then
-	    die 3 $"The module: $module is not located in the DKMS tree."
-	fi
-	template_kernel_status=$(echo "$template_kernel_status" | grep "^$module,")
+        # Make sure that its installed in the first place
+        if ! [[ -d $dkms_tree/$module/ ]]; then
+            die 3 $"The module: $module is not located in the DKMS tree."
+        fi
+        template_kernel_status=$(echo "$template_kernel_status" | grep "^$module,")
     fi
 
     echo $""
@@ -2713,56 +2811,53 @@ run_match()
 
     # Prepare the kernel just once but only if there is actual work to do
     if [[ ! $template_kernel_status ]]; then
-	echo $""
-	echo $"There is nothing to be done for this match."
+        echo $""
+        echo $"There is nothing to be done for this match."
     else
-	prepare_kernel "$kernelver" "$arch"
-
-	# Iterate over the kernel_status and match kernel to the template_kernel
-	while read template_line; do
-	    template_module=`echo "$template_line" | awk {'print $1'} | sed 's/,$//'`
-	    template_version=`echo "$template_line" | awk {'print $2'} | sed 's/,$//'`
-
-	    # Print out a match header
-	    echo $""
-	    echo $"---- Match Beginning ----"
-	    echo $"Module:  $template_module"
-	    echo $"Version: $template_version"
-	    echo $"-------------------------"
-
-	    # Figure out what to do from here
-	    if show_status "$template_module" "$template_version" "$kernelver" "$arch" 2>/dev/null | grep -q ": installed"; then
-		echo $""
-		echo $"This module/version combo is already installed.  Nothing to be done."
-	    elif show_status "$template_module" "$template_version" "$kernelver" "$arch" 2>/dev/null | grep -q ": built"; then
-		echo $""
-		echo $"This module/version combo is built.  Installing it:"
-		module="$template_module"
-		module_version="$template_version"
-		install_module
-	    else
-		echo $""
-		echo $"Building & Installing this module/version:"
-		module="$template_module"
-		module_version="$template_version"
-		build_module
-		install_module
-	    fi
-	done < <(echo "$template_kernel_status")
-
-	# Clean up the kernel tree
-	if [[ ! ( $(VER $kernelver) < $(VER 2.6.6) ) && \
-	    -d "$kernel_source_dir" && \
-	    ! -h "$kernel_source_dir" && \
-	    -z "$ksourcedir_fromcli" ]]; then
-	    echo $"Kernel cleanup unnecessary for this kernel.  Skipping..."
-	elif [[ ! $no_clean_kernel ]]; then
-	    cd "$kernel_source_dir"
-	    [[ $kerneldoth_contents ]] || invoke_command "make mrproper" "cleaning kernel tree (make mrproper)" background
-	    [[ $config_contents ]] && echo "$config_contents" > .config
-	    [[ $kerneldoth_contents ]] && echo "$kerneldoth_contents" > /boot/kernel.h
-	    cd - >/dev/null
-	fi
+    prepare_kernel "$kernelver" "$arch"
+
+    # Iterate over the kernel_status and match kernel to the template_kernel
+    while read template_line; do
+        template_module=`echo "$template_line" | awk {'print $1'} | sed 's/,$//'`
+        template_version=`echo "$template_line" | awk {'print $2'} | sed 's/,$//'`
+
+        # Print out a match header
+        echo $""
+        echo $"---- Match Beginning ----"
+        echo $"Module:  $template_module"
+        echo $"Version: $template_version"
+        echo $"-------------------------"
+
+        # Figure out what to do from here
+        if show_status "$template_module" "$template_version" "$kernelver" "$arch" 2>/dev/null | grep -q ": installed"; then
+            echo $""
+            echo $"This module/version combo is already installed.  Nothing to be done."
+        elif show_status "$template_module" "$template_version" "$kernelver" "$arch" 2>/dev/null | grep -q ": built"; then
+            echo $""
+            echo $"This module/version combo is built.  Installing it:"
+            module="$template_module"
+            module_version="$template_version"
+            install_module
+        else
+        echo $""
+        echo $"Building & Installing this module/version:"
+        module="$template_module"
+        module_version="$template_version"
+        build_module
+        install_module
+        fi
+    done < <(echo "$template_kernel_status")
+
+    # Clean up the kernel tree
+    if [[ ! ( $(VER $kernelver) < $(VER 2.6.6) ) && -d "$kernel_source_dir" && ! -h "$kernel_source_dir" && -z "$ksourcedir_fromcli" ]]; then
+        echo $"Kernel cleanup unnecessary for this kernel.  Skipping..."
+    elif [[ ! $no_clean_kernel ]]; then
+        cd "$kernel_source_dir"
+        [[ $kerneldoth_contents ]] || invoke_command "make mrproper" "cleaning kernel tree (make mrproper)" background
+        [[ $config_contents ]] && echo "$config_contents" > .config
+        [[ $kerneldoth_contents ]] && echo "$kerneldoth_contents" > /boot/kernel.h
+        cd - >/dev/null
+    fi
     fi
 
     # Done
@@ -2776,8 +2871,8 @@ make_rpm()
 
     # Check that the rpmbuild command is present
     if ! which rpmbuild >/dev/null 2>&1 ; then
-	die 1 $"rpmbuild not present." \
-	    $"Install the rpm-build package."
+        die 1 $"rpmbuild not present." \
+            $"Install the rpm-build package."
     fi
 
     # Read the conf file
@@ -2787,34 +2882,33 @@ make_rpm()
 
     echo $""
     local sp
-    for sp in "$dkms_tree/$module/$module_version/source/$module-dkms-mkrpm.spec" \
-	"/etc/dkms/template-dkms-mkrpm.spec"; do
-	[[ -e $sp ]] || continue
-	SPECFILE="$sp"
-	break
+    for sp in "$dkms_tree/$module/$module_version/source/$module-dkms-mkrpm.spec" "/etc/dkms/template-dkms-mkrpm.spec"; do
+        [[ -e $sp ]] || continue
+        SPECFILE="$sp"
+        break
     done
     if [[ ! $SPECFILE ]]; then
-	die 5 $"Cannot find $sp which is needed by" \
-	    $"DKMS in order use mkrpm."
+        die 5 $"Cannot find $sp which is needed by" \
+            $"DKMS in order use mkrpm."
     fi
 
     # Run a dkms mktarball for use in the rpm
     local mktarball_line
     if [[ ! $source_only || $binaries_only ]]; then
-	mktarball_line="--binaries-only"
-	local i
-	echo $""
-	for ((i=0; i<${#kernelver[@]}; i++)); do
-	    if ! [[ -d $dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]} ]]; then
-	    die 5 $"You do not seem to have $module $module_version built for" \
-		$"${kernelver[$i]} (${arch[$i]}).  All modules must be in" \
-		$"the built state before you can use mkrpm."
-	    fi
-	    echo $"Marking ${kernelver[$i]} (${arch[$i]}) for RPM..."
-	    mktarball_line="-k ${kernelver[$i]} -a ${arch[$i]} $mktarball_line"
-	done
+        mktarball_line="--binaries-only"
+        local i
+        echo $""
+        for ((i=0; i<${#kernelver[@]}; i++)); do
+            if ! [[ -d $dkms_tree/$module/$module_version/${kernelver[$i]}/${arch[$i]} ]]; then
+                die 5 $"You do not seem to have $module $module_version built for" \
+                    $"${kernelver[$i]} (${arch[$i]}).  All modules must be in" \
+                    $"the built state before you can use mkrpm."
+            fi
+            echo $"Marking ${kernelver[$i]} (${arch[$i]}) for RPM..."
+            mktarball_line="-k ${kernelver[$i]} -a ${arch[$i]} $mktarball_line"
+        done
     else
-	mktarball_line="none"
+        mktarball_line="none"
     fi
 
     local temp_dir_name=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
@@ -2822,26 +2916,26 @@ make_rpm()
     mkdir -p ${temp_dir_name}/{BUILD,RPMS,SRPMS,SPECS,SOURCES}
     cp ${SPECFILE} ${temp_dir_name}/SPECS/dkms_mkrpm.spec
 
-    #if using legacy mode, install common postinst
+    # If using legacy mode, install common postinst
     if ((legacy_postinst != 0)); then
-	invoke_command "cp '$PREFIX/usr/lib/dkms/common.postinst' '${temp_dir_name}/SOURCES'" "copying legacy postinstall template"
+        invoke_command "cp '$PREFIX/usr/lib/dkms/common.postinst' '${temp_dir_name}/SOURCES'" "copying legacy postinstall template"
     fi
 
-    #Copy in the source tree
+    # Copy in the source tree
     if [[ ! $binaries_only ]]; then
-	invoke_command "cp -Lpr '$dkms_tree/$module/$module_version/source' '${temp_dir_name}/SOURCES/$module-$module_version'" "Copying source tree"
+        invoke_command "cp -Lpr '$dkms_tree/$module/$module_version/source' '${temp_dir_name}/SOURCES/$module-$module_version'" "Copying source tree"
     fi
 
     if invoke_command "LC_ALL=C rpmbuild --define \"_topdir ${temp_dir_name}\" --define \"version $module_version\" --define \"module_name $module\" --define \"kernel_versions ${kernelver[*]}\" --define \"mktarball_line $mktarball_line\" --define \"__find_provides  /usr/lib/dkms/find-provides\" --define \"_use_internal_dependency_generator 0\" -ba ${temp_dir_name}/SPECS/dkms_mkrpm.spec > ${temp_dir_name}/rpmbuild.log 2>&1" "rpmbuild"; then
-	mkdir -p ${rpm_basedir}
-	cp -a ${temp_dir_name}/SRPMS/* ${temp_dir_name}/RPMS/*/* ${rpm_basedir}/
-	echo $""
-	cat ${temp_dir_name}/rpmbuild.log | grep ^Wrote | sed -e "s:${temp_dir_name}/:${rpm_basedir}/:" -e 's:SRPMS/::' -e 's:RPMS/.*/::'
-	echo $""
-	echo $"DKMS: mkrpm completed."
+        mkdir -p ${rpm_basedir}
+        cp -a ${temp_dir_name}/SRPMS/* ${temp_dir_name}/RPMS/*/* ${rpm_basedir}/
+        echo $""
+        cat ${temp_dir_name}/rpmbuild.log | grep ^Wrote | sed -e "s:${temp_dir_name}/:${rpm_basedir}/:" -e 's:SRPMS/::' -e 's:RPMS/.*/::'
+        echo $""
+        echo $"DKMS: mkrpm completed."
     else
-	cat ${temp_dir_name}/rpmbuild.log >&2
-	die 7 $"There was a problem creating your rpm."
+        cat ${temp_dir_name}/rpmbuild.log >&2
+        die 7 $"There was a problem creating your rpm."
     fi
     rm -rf $temp_dir_name
     trap > /dev/null 2>&1
@@ -2852,9 +2946,9 @@ preproc_file()
     local date_str="$(date -R)"
     echo "modifying $1..."
     sed -e "s/DEBIAN_PACKAGE/$debian_package/g" \
-	-e "s/MODULE_NAME/$module/g" \
-	-e "s/MODULE_VERSION/$module_version/g" \
-	-e "s/DATE_STAMP/$date_str/" "$1" > "$1.dkms-pp"
+        -e "s/MODULE_NAME/$module/g" \
+        -e "s/MODULE_VERSION/$module_version/g" \
+        -e "s/DATE_STAMP/$date_str/" "$1" > "$1.dkms-pp"
     mv "$1.dkms-pp" "$1"
 }
 
@@ -2864,37 +2958,43 @@ debian_install()
     local getroot  tmpfile i
     local -a packages=("$@")
     for ((i=0; i < ${#packages[@]}; i++)); do
-	dpkg-query -s "${packages[$i]}"| egrep -q '^Status:.* installed$' || continue
-	unset package[$i]
+        dpkg-query -s "${packages[$i]}"| egrep -q '^Status:.* installed$' || continue
+        unset package[$i]
     done
     # if they are already installed, we are OK.
     [[ ${package[@]} ]] || return
     if ((UID != 0)); then
-	# figure out how to get root
-	for getroot in su-to-root gksudo kdesu sudo; do
-	    which $getroot >/dev/null 2>&1 || continue
-	    case $getroot in
-		su-to-root) getroot="$getroot -c";;
-		gksudo) [[ $DISPLAY ]] || continue
-		    getroot="$getroot --description 'DKMS Debian package builder' ";;
-		kdesu) [[ $DISPLAY ]] || continue;;
-	    esac
-	    break
-	done
+        # figure out how to get root
+        for getroot in su-to-root gksudo kdesu sudo; do
+            which $getroot >/dev/null 2>&1 || continue
+            case $getroot in
+                su-to-root)
+                    getroot="$getroot -c"
+                    ;;
+                gksudo)
+                    [[ $DISPLAY ]] || continue
+                    getroot="$getroot --description 'DKMS Debian package builder' "
+                    ;;
+                kdesu)
+                    [[ $DISPLAY ]] || continue
+                    ;;
+            esac
+            break
+        done
     fi
     if [[ -x /usr/sbin/synaptic && $DISPLAY ]] && tmpfile=$(mktemp_or_die); then
-	# Pretty GUI install.
-	trap 'rm -f "$tmpfile"' EXIT
-	for ((i=0; i=${#packages[@]}; i++)); do
-	    [[ ${packages[$i]} ]] && echo "install ${packages[$i]}" >>$tmpfile
-	done
-	$getroot "sh -c '/usr/sbin/synaptic --set-selections --non-interactive --hide-main-window < $tmpfile'"
+        # Pretty GUI install.
+        trap 'rm -f "$tmpfile"' EXIT
+        for ((i=0; i=${#packages[@]}; i++)); do
+            [[ ${packages[$i]} ]] && echo "install ${packages[$i]}" >>$tmpfile
+        done
+        $getroot "sh -c '/usr/sbin/synaptic --set-selections --non-interactive --hide-main-window < $tmpfile'"
     else
-	$getroot apt-get -y install "${packages[@]}"
+        $getroot apt-get -y install "${packages[@]}"
     fi
     if (( $? != 0)); then
-	die 4 $"Missing ${packages[@]}" \
-	    $"and unable to install.  Please ask an admin to install for you."
+        die 4 $"Missing ${packages[@]}" \
+            $"and unable to install.  Please ask an admin to install for you."
     fi
 }
 
@@ -2913,87 +3013,87 @@ make_debian()
     read_conf_or_die "$kernelver" "$arch"
     debian_install fakeroot dpkg-dev debhelper
 
-    #skeleton to load templates from
+    # Skeleton to load templates from
     local system_mk="$dkms_tree/$module/$module_version/source/$module-dkms-mk${create_type}"
     local local_mk="/etc/dkms/template-dkms-mk${create_type}"
     if [[ -e ${system_mk} ]]; then
-	echo $"Using ${system_mk}"
-	DEBDIR=${system_mk}
+        echo $"Using ${system_mk}"
+        DEBDIR=${system_mk}
     elif [[ -e ${local_mk} ]]; then
-	echo $"Using ${local_mk}"
-	DEBDIR=${local_mk}
+        echo $"Using ${local_mk}"
+        DEBDIR=${local_mk}
     else
-	die 5 $"Cannot find ${local_mk} which is needed by" \
-	    $"DKMS in order to use mk${create_type}."
+        die 5 $"Cannot find ${local_mk} which is needed by" \
+            $"DKMS in order to use mk${create_type}."
     fi
 
-    #prepare build directory and copy template
+    # Prepare build directory and copy template
     local temp_dir=$(mktemp_or_die -d $tmp_location/dkms.XXXXXX)
     trap "rm -rf $temp_dir; delete_temporary_trees" EXIT HUP TERM
     local temp_dir_debian="$temp_dir/$debian_package-dkms-$module_version"
     invoke_command "cp -ar '$DEBDIR/' '$temp_dir_debian'" "copying template"
     pushd "$temp_dir_debian" > /dev/null 2>&1
     for file in debian/*; do
-	preproc_file "$file"
-	chmod 755 "$file"
+        preproc_file "$file"
+        chmod 755 "$file"
     done
     popd > /dev/null 2>&1
 
-     #if using legacy mode, install common postinst
+    # If using legacy mode, install common postinst
     if ((legacy_postinst != 0)); then
-	invoke_command "cp '$PREFIX/usr/lib/dkms/common.postinst' '$temp_dir_debian'" "copying legacy postinstall template"
+        invoke_command "cp '$PREFIX/usr/lib/dkms/common.postinst' '$temp_dir_debian'" "copying legacy postinstall template"
     fi
 
-    #Copy in the source tree
+    # Copy in the source tree
     if [[ ! $binaries_only ]]; then
-	invoke_command "cp -Lpr '$dkms_tree/$module/$module_version/source' '$temp_dir_debian/$module-$module_version'" "Copying source tree"
+        invoke_command "cp -Lpr '$dkms_tree/$module/$module_version/source' '$temp_dir_debian/$module-$module_version'" "Copying source tree"
     fi
 
-    #Only if we are shipping binary modules, make a .tgz for the deb
+    # Only if we are shipping binary modules, make a .tgz for the deb
     local archive_location="$dkms_tree/$module/$module_version/tarball/$module-$module_version.dkms.tar.gz"
     if [[ ! $source_only ]]; then
-	binaries_only="binaries-only"
-	invoke_command "make_tarball" "Gathering binaries"
-	if [[ -f $archive_location ]]; then
-	    invoke_command "cp '$archive_location' '$temp_dir_debian'" "Copying DKMS tarball into DKMS tree"
-	else
-	    die 12 $"Unable to find created tarball."
-	fi
+        binaries_only="binaries-only"
+        invoke_command "make_tarball" "Gathering binaries"
+        if [[ -f $archive_location ]]; then
+            invoke_command "cp '$archive_location' '$temp_dir_debian'" "Copying DKMS tarball into DKMS tree"
+        else
+            die 12 $"Unable to find created tarball."
+        fi
     fi
 
-    #calculate destination directory
+    # Calculate destination directory
     deb_basedir=$dkms_tree/$module/$module_version/${create_type}
     mkdir -p ${deb_basedir} >/dev/null 2>&1
 
-    #create deb
+    # Create deb
     pushd "$temp_dir_debian" > /dev/null 2>&1
     case "$create_type" in
-	dsc)
-	    invoke_command "dpkg-buildpackage -S -us -uc 1>/dev/null" "Building source package" || \
-		die 7 $"There was a problem creating your ${create_type}."
-	    echo $""
-	    echo $"DKMS: mk${create_type} completed."
-	    invoke_command "mv '$temp_dir/${debian_package}-dkms_${module_version}_source.changes' '$temp_dir/${debian_package}-dkms_${module_version}.dsc' '$temp_dir/${debian_package}-dkms_${module_version}.tar.gz' '$deb_basedir'" "Moving built files to $deb_basedir"
-	    ;;
-	deb)
-	    invoke_command "dpkg-buildpackage -rfakeroot -d -b -us -uc 1>/dev/null" "Building binary package" || \
-		die 7 $"There was a problem creating your ${create_type}."
-	    echo $""
-	    echo $"DKMS: mk${create_type} completed."
-	    invoke_command "mv '$temp_dir/${debian_package}-dkms_${module_version}_all.deb' '$deb_basedir'" "Moving built files to $deb_basedir"
-	    ;;
+    dsc)
+        invoke_command "dpkg-buildpackage -S -us -uc 1>/dev/null" "Building source package" || \
+            die 7 $"There was a problem creating your ${create_type}."
+        echo $""
+        echo $"DKMS: mk${create_type} completed."
+        invoke_command "mv '$temp_dir/${debian_package}-dkms_${module_version}_source.changes' '$temp_dir/${debian_package}-dkms_${module_version}.dsc' '$temp_dir/${debian_package}-dkms_${module_version}.tar.gz' '$deb_basedir'" "Moving built files to $deb_basedir"
+        ;;
+    deb)
+        invoke_command "dpkg-buildpackage -rfakeroot -d -b -us -uc 1>/dev/null" "Building binary package" || \
+            die 7 $"There was a problem creating your ${create_type}."
+        echo $""
+        echo $"DKMS: mk${create_type} completed."
+        invoke_command "mv '$temp_dir/${debian_package}-dkms_${module_version}_all.deb' '$deb_basedir'" "Moving built files to $deb_basedir"
+        ;;
     esac
     popd > /dev/null 2>&1
 
     if in_temporary_trees; then
-	echo "Copying built files to "`pwd`"/.." >&2
-	cp "${deb_basedir}/"* ..
+        echo "Copying built files to "`pwd`"/.." >&2
+        cp "${deb_basedir}/"* ..
     fi
 
-    #cleanup
+    # Cleanup
     invoke_command "rm $temp_dir -fr" "Cleaning up temporary files"
     delete_temporary_trees || \
-	die 7 $"There was a problem cleaning up temporary files."
+        die 7 $"There was a problem cleaning up temporary files."
 }
 
 make_common_test()
@@ -3007,8 +3107,8 @@ make_common_test()
 
     # Make sure that its installed in the first place
     [[ -d $dkms_tree/$module/$module_version ]] ||
-	die 3 $"The module/version combo: $module-$module_version" \
-	    $"is not located in the DKMS tree."
+        die 3 $"The module/version combo: $module-$module_version" \
+        $"is not located in the DKMS tree."
 }
 
 make_kmp_srpm()
@@ -3017,8 +3117,7 @@ make_kmp_srpm()
     trap 'rm -rf $temp_dir_name' EXIT HUP TERM
     mkdir -p $temp_dir_name/{BUILD,RPMS,SRPMS,SPECS,SOURCES}
     pushd "$dkms_tree/$module/$module_version" > /dev/null 2>&1
-    # want to change name of the top-level of the tarball
-    # from build to $module-$module_version
+    # Want to change name of the top-level of the tarball from build to $module-$module_version
     cp -lr build ${module}-${module_version}
     tar cvjf $temp_dir_name/SOURCES/${module}-${module_version}.tar.bz2 ${module}-${module_version} > /dev/null 2>&1
     rm -rf ${module}-${module_version}
@@ -3028,12 +3127,12 @@ make_kmp_srpm()
     grep ^Wrote $temp_dir_name/rpmbuild.log > /dev/null 2>&1
     local RC="$?"
     if ((RC == 0)); then
-	local kmp_basedir="$dkms_tree/$module/$module_version/rpm"
-	mkdir -p $kmp_basedir
-	RPMS=$(LANG=C cp -va ${temp_dir_name}/SRPMS/* $kmp_basedir | awk '{print $NF}')
+        local kmp_basedir="$dkms_tree/$module/$module_version/rpm"
+        mkdir -p $kmp_basedir
+        RPMS=$(LANG=C cp -va ${temp_dir_name}/SRPMS/* $kmp_basedir | awk '{print $NF}')
     else
-	echo $"rpmbuild error log:"
-	cat $temp_dir_name/rpmbuild.log
+        echo $"rpmbuild error log:"
+        cat $temp_dir_name/rpmbuild.log
     fi
     popd > /dev/null 2>&1
     rm -rf $temp_dir_name
@@ -3043,9 +3142,9 @@ make_kmp_srpm()
 
 report_build_problem()
 {
-    #If apport is on the system, files a build problem
+    # If apport is on the system, files a build problem
     if [ -x /usr/share/apport/apport ] && which python3 >/dev/null; then
-	python3 /usr/share/apport/package-hooks/dkms_packages.py -m $module -v $module_version -k ${kernelver[0]}
+        python3 /usr/share/apport/package-hooks/dkms_packages.py -m $module -v $module_version -k ${kernelver[0]}
     fi
     die "$@"
 }
@@ -3059,12 +3158,12 @@ read_arg() {
     # $3 = arg parameter
     local rematch='^[^=]*=(.*)$'
     if [[ $2 =~ $rematch ]]; then
-	read "$1" <<< "${BASH_REMATCH[1]}"
+        read "$1" <<< "${BASH_REMATCH[1]}"
     else
-	read "$1" <<< "$3"
-	# There is no way to shift our callers args, so
-	# return 1 to indicate they should do it instead.
-	return 1
+        read "$1" <<< "$3"
+        # There is no way to shift our callers args, so
+        # return 1 to indicate they should do it instead.
+        return 1
     fi
 }
 
@@ -3075,10 +3174,10 @@ read_arg() {
 # they are all passed at the same time.
 parse_kernelarch(){
     if [[ $1 =~ $mv_re ]]; then
-	kernelver[${#kernelver[@]}]="${BASH_REMATCH[1]}"
-	arch[${#arch[@]}]="${BASH_REMATCH[2]}"
+        kernelver[${#kernelver[@]}]="${BASH_REMATCH[1]}"
+        arch[${#arch[@]}]="${BASH_REMATCH[2]}"
     else
-	kernelver[${#kernelver[@]}]="$1"
+        kernelver[${#kernelver[@]}]="$1"
     fi
 }
 
@@ -3090,10 +3189,10 @@ parse_kernelarch(){
 # commands on the commandline.
 parse_moduleversion(){
     if [[ $1 =~ $mv_re ]]; then
-	module="${BASH_REMATCH[1]}"
-	module_version="${BASH_REMATCH[2]}"
+        module="${BASH_REMATCH[1]}"
+        module_version="${BASH_REMATCH[2]}"
     else
-	module="$1"
+        module="$1"
     fi
 }
 
@@ -3108,26 +3207,32 @@ check_root() {
 add_source_tree() {
     local from=$(readlink -f $1)
     if ! [[ $from && -f $from/dkms.conf ]]; then
-	die 9 $"$1 must contain a dkms.conf file!"
+        die 9 $"$1 must contain a dkms.conf file!"
     fi
     check_root
     setup_kernels_arches
     if ! get_pkginfo_from_conf "$from/dkms.conf" ; then
-	die 10 $"Malformed dkms.conf file. Cannot load source tree."
+        die 10 $"Malformed dkms.conf file. Cannot load source tree."
     fi
     module="$PACKAGE_NAME"
     module_version="$PACKAGE_VERSION"
     if [[ $force && -d $source_tree/$module-$module_version ]]; then
-	echo >&2
-	echo $"Forcing install of $module-$module_version"
-	rm -rf "$source_tree/$module-$module_version"
+        echo >&2
+        echo $"Forcing install of $module-$module_version"
+        rm -rf "$source_tree/$module-$module_version"
     fi
 
     # We are already installed, just return.
     case $from in
-	"$source_tree/$module-$module_version") return;;
-	"$dkms_tree/$module/$version/source") return;;
-	"$dkms_tree/$module/$version/build") return;;
+        "$source_tree/$module-$module_version")
+            return
+            ;;
+        "$dkms_tree/$module/$version/source")
+            return
+            ;;
+        "$dkms_tree/$module/$version/build")
+            return
+            ;;
     esac
     mkdir -p "$source_tree/$module-$module_version"
     cp -fr "$from"/* "$source_tree/$module-$module_version"
@@ -3142,14 +3247,14 @@ make_kmp()
 
     echo $""
     if [[ $specfile && -e $dkms_tree/$module/$module_version/source/$specfile ]]; then
-	echo $"Using $dkms_tree/$module/$module_version/source/$specfile"
-	SPECFILE="$dkms_tree/$module/$module_version/source/$specfile"
+        echo $"Using $dkms_tree/$module/$module_version/source/$specfile"
+        SPECFILE="$dkms_tree/$module/$module_version/source/$specfile"
     elif [[ -e $dkms_tree/$module/$module_version/source/$module-kmp.spec ]]; then
-	echo $"Using $dkms_tree/$module/$module_version/source/$module-kmp.spec"
-	SPECFILE="$dkms_tree/$module/$module_version/source/$module-kmp.spec"
+        echo $"Using $dkms_tree/$module/$module_version/source/$module-kmp.spec"
+        SPECFILE="$dkms_tree/$module/$module_version/source/$module-kmp.spec"
     else
-	die 5 $"Cannot find a suitable spec file which is needed by" \
-	    $"DKMS in order use mkkmp.  Please specify --spec=specfile."
+        die 5 $"Cannot find a suitable spec file which is needed by" \
+            $"DKMS in order use mkkmp.  Please specify --spec=specfile."
     fi
 
     prepare_build
@@ -3158,12 +3263,12 @@ make_kmp()
     clean_build
 
     if ((RC == 0)); then
-	echo $""
-	echo $"KMP SRPM location: $RPMS"
-	echo $""
-	echo $"DKMS: mkkmp completed."
+        echo $""
+        echo $"KMP SRPM location: $RPMS"
+        echo $""
+        echo $"DKMS: mkkmp completed."
     else
-	die 7 $"There was a problem creating your KMP source rpm."
+        die 7 $"There was a problem creating your KMP source rpm."
     fi
     # FIXME: hand SRPM to mock or build system to build
 }
@@ -3198,13 +3303,13 @@ autoinstall() {
         fi
         # If the module is already installed or weak-installed, skip it.
         if _is_module_installed "$m" "$v" "$kernelver" "$arch"; then
-		installed_modules[${#installed_modules[@]}]="$m"
-		continue
-	fi
+            installed_modules[${#installed_modules[@]}]="$m"
+            continue
+        fi
         if module_status_weak "$m" "$v" "$kernelver" "$arch" >/dev/null; then
-		installed_modules[${#installed_modules[@]}]="$m"
-		continue
-	fi
+            installed_modules[${#installed_modules[@]}]="$m"
+            continue
+        fi
         # if the module does not want to be autoinstalled, skip it.
         read_conf_or_die "$k" "$a" "$dkms_tree/$m/$v/source/dkms.conf"
         if [[ ! $AUTOINSTALL ]]; then
@@ -3226,49 +3331,49 @@ autoinstall() {
 
     [[ $to_install ]] || return 0
 
-	while true; do
-		install_count=0
-		next_install=( )
-
-		# Step 1: Remove installed modules from all dependency lists.
-		for m in ${!build_depends[@]}; do
-			next_depends=
-			for d in ${build_depends[$m]}; do
-				for i in ${installed_modules[@]}; do
-					[[ "$d" = "$i" ]] && continue 2
-				done
-				next_depends+="$d "
-			done
-			build_depends[$m]="${next_depends%% }"
-		done
-
-		# Step 2: Install modules that have an empty dependency list.
-		for mv in "${to_install[@]}"; do
-			IFS=/ read m v <<< "$mv"
-			if [[ -z "${build_depends[$m]}" ]]; then
-				(module="$m"; module_version="$v"; install_module)
-				installed_modules[${#installed_modules[@]}]="$m"
-				install_count=$(($install_count +1))
-			else
-				next_install[${#next_install[@]}]="$mv"
-			fi
-		done
-
-		wait
-
-		# Step 3: Keep going if at least one module was installed during
-		# this iteration.
-		[[ "$install_count" -gt 0 ]] || break;
-
-		# Step 4: Remove modules that were installed during Step 2 from
-		# the job queue.
-		to_install=( "${next_install[@]}" )
-
-	done
-	for mv in "${to_install[@]}"; do
-		IFS=/ read m v <<< "$mv"
-		echo "$m/$v autoinstall failed due to missing dependencies: ${build_depends[$m]}"
-	done
+    while true; do
+        install_count=0
+        next_install=( )
+
+        # Step 1: Remove installed modules from all dependency lists.
+        for m in ${!build_depends[@]}; do
+            next_depends=
+            for d in ${build_depends[$m]}; do
+                for i in ${installed_modules[@]}; do
+                    [[ "$d" = "$i" ]] && continue 2
+                done
+                next_depends+="$d "
+            done
+            build_depends[$m]="${next_depends%% }"
+        done
+
+        # Step 2: Install modules that have an empty dependency list.
+        for mv in "${to_install[@]}"; do
+            IFS=/ read m v <<< "$mv"
+            if [[ -z "${build_depends[$m]}" ]]; then
+                (module="$m"; module_version="$v"; install_module)
+                installed_modules[${#installed_modules[@]}]="$m"
+                install_count=$(($install_count +1))
+            else
+                next_install[${#next_install[@]}]="$mv"
+            fi
+        done
+
+        wait
+
+        # Step 3: Keep going if at least one module was installed during
+        # this iteration.
+        [[ "$install_count" -gt 0 ]] || break;
+
+        # Step 4: Remove modules that were installed during Step 2 from
+        # the job queue.
+        to_install=( "${next_install[@]}" )
+
+    done
+    for mv in "${to_install[@]}"; do
+        IFS=/ read m v <<< "$mv"
+        echo "$m/$v autoinstall failed due to missing dependencies: ${build_depends[$m]}"
+    done
 }
 
 function make_redhat3_driver_disk ()
@@ -3353,7 +3458,7 @@ function make_redhat3_driver_disk ()
     cd $temp_dir_name/SOURCES
     invoke_command "tar -jcvf $temp_dir_name/SOURCES/$module-$module_version.tar.bz2 $module-$module_version/" "creating source tarball"
     local i=0
-    #Build RPMS
+    # Build RPMS
     while [ $i -lt ${#kernelver[@]} ]; do
         invoke_command "LC_ALL=C rpmbuild --define \"_topdir ${temp_dir_name}\" --define \"version $module_version\" --define \"module_name $module\" --define \"kernel_version ${kernelver[$i]}\" -bb --target ${arch[$i]} ${temp_dir_name}/SPECS/$module.spec > ${temp_dir_name}/rpmbuild.log 2>&1" "rpmbuild"
         if [ "$?" -ne 0 ]; then
@@ -3459,7 +3564,7 @@ verbose=""
 symlink_modules=""
 dkms_frameworkconf="/etc/dkms/framework.conf"
 
-# these can come from the environment or the config file
+# These can come from the environment or the config file
 [[ ! ${ADDON_MODULES_DIR} && -e /etc/sysconfig/module-init-tools ]] && . /etc/sysconfig/module-init-tools
 addon_modules_dir="${ADDON_MODULES_DIR}"
 [[ ! ${addon_modules_dir} ]] && running_distribution="$(distro_version)"
@@ -3507,66 +3612,137 @@ action_re='^(remove|(auto|un)?install|match|mk(driverdisk|tarball|rpm|deb|dsc|km
 # Parse command line arguments
 while (($# > 0)); do
     case $1 in
-	--dkmsframework*)    read_arg dkms_frameworkconf "$1" "$2" || shift
-			     #immediately load this config
-			     . $dkms_frameworkconf 2> /dev/null;;
-	--module*|-m)        read_arg _mv "$1" "$2" || shift
-			     parse_moduleversion "$_mv";;
-	-v)                  read_arg module_version "$1" "$2" || shift;;
-	--kernelver*|-k)     read_arg _ka "$1" "$2" || shift
-			     parse_kernelarch "$_ka";;
-	--distro*|-d)        read_arg distro "$1" "$2" || shift;;
-	--media*)            read_arg media "$1" "$2" ||shift;;
-	--release*|-r)       read_arg release "$1" "$2" || shift;;
-	--templatekernel*)   read_arg template_kernel "$1" "$2" || shift;;
-	-c)                  read_arg conf "$1" "$2" || shift;;
-	--quiet|-q)          exec >/dev/null 2>&1;;
-	--version|-V)        echo $"dkms: [INSERT_VERSION_HERE]"
-			     exit 0;;
-	--no-prepare-kernel) no_prepare_kernel="no-prepare-kernel";;
-	--no-clean-kernel)   no_clean_kernel="no-clean-kernel";;
-	--no-initrd)         no_initrd="no-initrd";;
-	--binaries-only)     binaries_only="binaries-only";;
-	--source-only)       source_only="source-only";;
-	--force)             force="true";;
-	--all)               all="true";;
-	--verbose)           verbose="true";;
-	--rpm_safe_upgrade)  rpm_safe_upgrade="true";;
-	--dkmstree*)         read_arg dkms_tree "$1" "$2" || shift;;
-	--sourcetree*)       read_arg source_tree "$1" "$2" || shift;;
-	--installtree*)      read_arg install_tree "$1" "$2" || shift;;
-	--symlink-modules)   symlink_module="true";;
-	--config*)           read_arg kernel_config "$1" "$2" || shift;;
-	--archive*)          read_arg archive_location "$1" "$2" || shift;;
-	--legacy-postinst*)  read_arg legacy_postinst "$1" "$2" || shift;;
-	--arch*|-a)          read_arg _aa "$1" "$2" || shift
-			     arch[${#arch[@]}]="$_aa";;
-	--size*)             read_arg size "$1" "$2" || shift;;
-	--kernelsourcedir*)  read_arg kernel_source_dir "$1" "$2" || shift
-			     ksourcedir_fromcli="true";;
-	--directive*)        read_arg _da "$1" "$2" || shift
-			     directive_array[${#directive_array[@]}]="$_da";;
-	--spec*)             read_arg specfile "$1" "$2" || shift;;
-	--no-depmod)         no_depmod="true";;
-	--debug)
-	    export PS4='${BASH_SOURCE}@${LINENO}(${FUNCNAME[0]}): '
-	    set -x;;
-	-*|--*)              error $" Unknown option: $1"
-			     show_usage
-			     exit 2;;
-	*) if [[ $1 =~ $action_re ]]; then
-	    action="$action $1" # Add actions to the action list
-	    elif [[ -f $1 && $1 = *dkms.conf ]]; then
-	    try_source_tree="${1%dkms.conf}./" # Flag as a source tree
-	    elif [[ -d $1 && -f $1/dkms.conf ]]; then
-	    try_source_tree="$1" # ditto
-	    elif [[ -f $1 ]]; then
-	    archive_location="$1" # It is a file, assume it is an archive.
-	    elif [[ ! $module ]]; then
-	    parse_moduleversion "$1" # Assume it is a module/version pair.
-	    else
-	    warn $"I do not know how to handle $1."
-	    fi;;
+        --dkmsframework*)
+            read_arg dkms_frameworkconf "$1" "$2" || shift
+            #immediately load this config
+            . $dkms_frameworkconf 2> /dev/null
+            ;;
+        --module*|-m)
+            read_arg _mv "$1" "$2" || shift
+            parse_moduleversion "$_mv"
+            ;;
+        -v)
+            read_arg module_version "$1" "$2" || shift
+            ;;
+        --kernelver*|-k)
+            read_arg _ka "$1" "$2" || shift
+            parse_kernelarch "$_ka"
+            ;;
+        --distro*|-d)
+            read_arg distro "$1" "$2" || shift
+            ;;
+        --media*)
+            read_arg media "$1" "$2" ||shift
+            ;;
+        --release*|-r)
+            read_arg release "$1" "$2" || shift
+            ;;
+        --templatekernel*)
+            read_arg template_kernel "$1" "$2" || shift
+            ;;
+        -c)
+            read_arg conf "$1" "$2" || shift
+            ;;
+        --quiet|-q)
+            exec >/dev/null 2>&1
+            ;;
+        --version|-V)
+            echo $"dkms: [INSERT_VERSION_HERE]"
+            exit 0
+            ;;
+        --no-prepare-kernel)
+            no_prepare_kernel="no-prepare-kernel"
+            ;;
+        --no-clean-kernel)
+            no_clean_kernel="no-clean-kernel"
+            ;;
+        --no-initrd)
+            no_initrd="no-initrd"
+            ;;
+        --binaries-only)
+            binaries_only="binaries-only"
+            ;;
+        --source-only)
+            source_only="source-only"
+            ;;
+        --force)
+            force="true"
+            ;;
+        --all)
+            all="true"
+            ;;
+        --verbose)
+            verbose="true"
+            ;;
+        --rpm_safe_upgrade)
+            rpm_safe_upgrade="true"
+            ;;
+        --dkmstree*)
+            read_arg dkms_tree "$1" "$2" || shift
+            ;;
+        --sourcetree*)
+            read_arg source_tree "$1" "$2" || shift
+            ;;
+        --installtree*)
+            read_arg install_tree "$1" "$2" || shift
+            ;;
+        --symlink-modules)
+            symlink_module="true"
+            ;;
+        --config*)
+            read_arg kernel_config "$1" "$2" || shift
+            ;;
+        --archive*)
+            read_arg archive_location "$1" "$2" || shift
+            ;;
+        --legacy-postinst*)
+            read_arg legacy_postinst "$1" "$2" || shift
+            ;;
+        --arch*|-a)
+            read_arg _aa "$1" "$2" || shift
+            arch[${#arch[@]}]="$_aa"
+            ;;
+        --size*)
+            read_arg size "$1" "$2" || shift
+            ;;
+        --kernelsourcedir*)
+            read_arg kernel_source_dir "$1" "$2" || shift
+            ksourcedir_fromcli="true"
+            ;;
+        --directive*)
+            read_arg _da "$1" "$2" || shift
+            directive_array[${#directive_array[@]}]="$_da"
+            ;;
+        --spec*)
+            read_arg specfile "$1" "$2" || shift
+            ;;
+        --no-depmod)
+            no_depmod="true"
+            ;;
+        --debug)
+            export PS4='${BASH_SOURCE}@${LINENO}(${FUNCNAME[0]}): '
+            set -x
+            ;;
+        -*|--*)
+            error $" Unknown option: $1"
+            show_usage
+            exit 2
+            ;;
+        *)
+            if [[ $1 =~ $action_re ]]; then
+                action="$action $1" # Add actions to the action list
+            elif [[ -f $1 && $1 = *dkms.conf ]]; then
+                try_source_tree="${1%dkms.conf}./" # Flag as a source tree
+            elif [[ -d $1 && -f $1/dkms.conf ]]; then
+                try_source_tree="$1" # ditto
+            elif [[ -f $1 ]]; then
+                archive_location="$1" # It is a file, assume it is an archive.
+            elif [[ ! $module ]]; then
+                parse_moduleversion "$1" # Assume it is a module/version pair.
+            else
+                warn $"I do not know how to handle $1."
+            fi
+            ;;
     esac
     shift
 done
@@ -3576,26 +3752,26 @@ done
 # Error out if binaries-only is set and source-only is set
 if [[ $binaries_only && $source_only ]]; then
     die 8 $" You have specified both --binaries-only and --source-only." \
-	$"You cannot do this."
+        $"You cannot do this."
 fi
 
 # Error if # of arches doesn't match # of kernels
 if (( ${#kernelver[@]} != ${#arch[@]} && \
     ${#arch[@]} > 1 )); then
     die 1 $" If more than one arch is specified on the command line, then there" \
-	$"must be an equal number of kernel versions also specified (1:1 relationship)."
+        $"must be an equal number of kernel versions also specified (1:1 relationship)."
 fi
 
 # Check that kernel version and all aren't both set simultaneously
 if [[ $kernelver && $all ]]; then
     die 2 $" You cannot specify a kernel version and also specify" \
-	$"--all on the command line."
+        $"--all on the command line."
 fi
 
 # Check that arch and all aren't both set simultaneously
 if [[ $arch && $all ]]; then
     die 3 $" You cannot specify an arch and also specify" \
-	$"--all on the command line."
+        $"--all on the command line."
 fi
 
 # If initramfs/initrd rebuild is not requested, skip it with Redhat's weak-modules
@@ -3616,28 +3792,61 @@ fi
 for action_to_run in $action; do
     setup_kernels_arches "$action_to_run"
     case "$action_to_run" in
-	remove)       check_root && remove_module;;
-	install)      check_root && install_modules;;
-	autoinstall)  check_root && autoinstall;;
-	match)        check_root && have_one_kernel && run_match;;
-	uninstall)    check_root && have_one_kernel && uninstall_module;;
-	mkdriverdisk) check_root && make_driver_disk;;
-	build)        build_modules;;
-	add)          add_module;;
-	mktarball)    make_tarball;;
-	mkrpm)        make_rpm;;
-	mkdeb)        make_debian "deb";;
-	mkdsc)        make_debian "dsc";;
-	mkkmp)        have_one_kernel && make_kmp;;
-	status)       show_status;;
-	ldtarball) # Make sure they're root if we're using --force
-	    if ((UID != 0)) && [[ $force = true ]]; then
-		die 1 $"You must be root to use this command with the --force option."
-	    fi
-	    load_tarball && add_module;;
-	'') error $"No action was specified."
-	    show_usage;;
-	*)  error $"Unknown action specified: $action_to_run"
-	    show_usage;;
+    remove)
+        check_root && remove_module
+        ;;
+    install)
+        check_root && install_modules
+        ;;
+    autoinstall)
+        check_root && autoinstall
+        ;;
+    match)
+        check_root && have_one_kernel && run_match
+        ;;
+    uninstall)
+        check_root && have_one_kernel && uninstall_module
+        ;;
+    mkdriverdisk)
+        check_root && make_driver_disk
+        ;;
+    build)
+        build_modules
+        ;;
+    add)
+        add_module
+        ;;
+    mktarball)
+        make_tarball
+        ;;
+    mkrpm)
+        make_rpm
+        ;;
+    mkdeb)
+        make_debian "deb"
+        ;;
+    mkdsc)
+        make_debian "dsc"
+        ;;
+    mkkmp)
+        have_one_kernel && make_kmp
+        ;;
+    status)
+        show_status
+        ;;
+    ldtarball) # Make sure they're root if we're using --force
+        if ((UID != 0)) && [[ $force = true ]]; then
+            die 1 $"You must be root to use this command with the --force option."
+        fi
+        load_tarball && add_module
+        ;;
+    '')
+        error $"No action was specified."
+        show_usage
+        ;;
+    *)
+        error $"Unknown action specified: $action_to_run"
+        show_usage
+        ;;
     esac
 done
